<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java并发 | 八股文突击</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/interview-docs/title_image.jpg">
    <meta name="description" content="八股文">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/interview-docs/assets/css/0.styles.55d288df.css" as="style"><link rel="preload" href="/interview-docs/assets/js/app.67f6cb80.js" as="script"><link rel="preload" href="/interview-docs/assets/js/2.eee71d3c.js" as="script"><link rel="preload" href="/interview-docs/assets/js/1.a356cc6d.js" as="script"><link rel="preload" href="/interview-docs/assets/js/30.18027547.js" as="script"><link rel="prefetch" href="/interview-docs/assets/js/10.b84b4006.js"><link rel="prefetch" href="/interview-docs/assets/js/11.20da52d6.js"><link rel="prefetch" href="/interview-docs/assets/js/12.4911934c.js"><link rel="prefetch" href="/interview-docs/assets/js/13.00e67b44.js"><link rel="prefetch" href="/interview-docs/assets/js/14.f870dddb.js"><link rel="prefetch" href="/interview-docs/assets/js/15.4db24ad4.js"><link rel="prefetch" href="/interview-docs/assets/js/16.b2b962cf.js"><link rel="prefetch" href="/interview-docs/assets/js/17.a516a10b.js"><link rel="prefetch" href="/interview-docs/assets/js/18.4cf2b64e.js"><link rel="prefetch" href="/interview-docs/assets/js/19.e09e0a96.js"><link rel="prefetch" href="/interview-docs/assets/js/20.45806a88.js"><link rel="prefetch" href="/interview-docs/assets/js/21.84197de1.js"><link rel="prefetch" href="/interview-docs/assets/js/22.3a473303.js"><link rel="prefetch" href="/interview-docs/assets/js/23.aaadbf8e.js"><link rel="prefetch" href="/interview-docs/assets/js/24.86e0c1e4.js"><link rel="prefetch" href="/interview-docs/assets/js/25.7a257b9a.js"><link rel="prefetch" href="/interview-docs/assets/js/26.adb4e421.js"><link rel="prefetch" href="/interview-docs/assets/js/27.ad9e26de.js"><link rel="prefetch" href="/interview-docs/assets/js/28.62824fc2.js"><link rel="prefetch" href="/interview-docs/assets/js/29.d77f3b73.js"><link rel="prefetch" href="/interview-docs/assets/js/3.af785b85.js"><link rel="prefetch" href="/interview-docs/assets/js/31.c020db7a.js"><link rel="prefetch" href="/interview-docs/assets/js/32.12eb4ef7.js"><link rel="prefetch" href="/interview-docs/assets/js/33.e09993aa.js"><link rel="prefetch" href="/interview-docs/assets/js/34.889f87e4.js"><link rel="prefetch" href="/interview-docs/assets/js/4.b3ca86ef.js"><link rel="prefetch" href="/interview-docs/assets/js/5.09b8f077.js"><link rel="prefetch" href="/interview-docs/assets/js/6.8af05914.js"><link rel="prefetch" href="/interview-docs/assets/js/7.abcf6bba.js"><link rel="prefetch" href="/interview-docs/assets/js/vendors~docsearch.bdb6b9f7.js">
    <link rel="stylesheet" href="/interview-docs/assets/css/0.styles.55d288df.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><main><main slot="sidebar-top"><!----></main> <div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/interview-docs/" class="home-link router-link-active"><!----> <span class="site-name">八股文突击</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/interview-docs/" class="nav-link router-link-active">
  Index
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Interview-Doc" class="dropdown-title"><span class="title">Interview-Doc</span> <span class="arrow down"></span></button> <button type="button" aria-label="Interview-Doc" class="mobile-dropdown-title"><span class="title">Interview-Doc</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/01-Java基础.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/02-Redis.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/03-MySQL.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/04-Java框架.html" class="nav-link">
  Java框架
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/05-微服务.html" class="nav-link">
  微服务
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/06-消息中间件.html" class="nav-link">
  消息中间件
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/07-Java集合.html" class="nav-link">
  Java集合
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/08-Java并发.html" class="nav-link">
  Java并发
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/09-JVM.html" class="nav-link">
  JVM
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/数据结构与算法.html" class="nav-link">
  数据结构与算法
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/校园行(Campus-trip).html" class="nav-link">
  校园行(Campus-trip)
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/知识小站(Knowledge-Station).html" class="nav-link">
  知识小站(Knowledge-Station)
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/interview-docs/" class="nav-link router-link-active">
  Index
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Interview-Doc" class="dropdown-title"><span class="title">Interview-Doc</span> <span class="arrow down"></span></button> <button type="button" aria-label="Interview-Doc" class="mobile-dropdown-title"><span class="title">Interview-Doc</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/01-Java基础.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/02-Redis.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/03-MySQL.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/04-Java框架.html" class="nav-link">
  Java框架
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/05-微服务.html" class="nav-link">
  微服务
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/06-消息中间件.html" class="nav-link">
  消息中间件
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/07-Java集合.html" class="nav-link">
  Java集合
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/08-Java并发.html" class="nav-link">
  Java并发
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/09-JVM.html" class="nav-link">
  JVM
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/数据结构与算法.html" class="nav-link">
  数据结构与算法
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/校园行(Campus-trip).html" class="nav-link">
  校园行(Campus-trip)
</a></li><li class="dropdown-item"><!----> <a href="/interview-docs/my-docs/Interview/知识小站(Knowledge-Station).html" class="nav-link">
  知识小站(Knowledge-Station)
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/interview-docs/" aria-current="page" class="sidebar-link">学前必读</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Interview</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview-docs/my-docs/Interview/01-Java基础.html" class="sidebar-link">Java基础</a></li><li><a href="/interview-docs/my-docs/Interview/02-Redis.html" class="sidebar-link">Redis</a></li><li><a href="/interview-docs/my-docs/Interview/03-MySQL.html" class="sidebar-link">MySQL</a></li><li><a href="/interview-docs/my-docs/Interview/04-Java框架.html" class="sidebar-link">Java框架</a></li><li><a href="/interview-docs/my-docs/Interview/05-微服务.html" class="sidebar-link">微服务</a></li><li><a href="/interview-docs/my-docs/Interview/06-消息中间件.html" class="sidebar-link">消息中间件</a></li><li><a href="/interview-docs/my-docs/Interview/07-Java集合.html" class="sidebar-link">Java集合</a></li><li><a href="/interview-docs/my-docs/Interview/08-Java并发.html" class="active sidebar-link">Java并发</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#基础知识" class="sidebar-link">基础知识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程和进程有什么区别✔" class="sidebar-link">线程和进程有什么区别✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#创建线程的三种方式的对比✔" class="sidebar-link">创建线程的三种方式的对比✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#为什么要使用多线程呢" class="sidebar-link">为什么要使用多线程呢</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程的状态流转✔" class="sidebar-link">线程的状态流转✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#什么是线程死锁-如何避免死锁✔❕" class="sidebar-link">什么是线程死锁?如何避免死锁✔❕</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#如何进行死锁诊断" class="sidebar-link">如何进行死锁诊断</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#concurrenthashmap-底层具体实现原理✔" class="sidebar-link">ConcurrentHashMap 底层具体实现原理✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#常见的对比✔" class="sidebar-link">常见的对比✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程池中shutdown-和shutdownnow-方法的区别✔" class="sidebar-link">线程池中shutdown()和shutdownNow()方法的区别✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#sleep-方法和-wait-方法区别和共同点✔" class="sidebar-link">sleep() 方法和 wait() 方法区别和共同点✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#thread-sleep-0-有意义吗✔" class="sidebar-link">Thread.sleep(0)有意义吗✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程的-run-和-start-有什么区别" class="sidebar-link">线程的 run()和 start()有什么区别</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#新建-t1、t2、t3-三个线程-如何保证它们按顺序执行✔" class="sidebar-link">新建 T1、T2、T3 三个线程，如何保证它们按顺序执行✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#notify-和-notifyall-有什么区别✔" class="sidebar-link">notify()和 notifyAll()有什么区别✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#wait和notify为什么要在synchronized代码块中✔" class="sidebar-link">wait和notify为什么要在synchronized代码块中✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#如何停止一个正在运行的线程" class="sidebar-link">如何停止一个正在运行的线程</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#如何知道线程池中的任务已经执行完成✔" class="sidebar-link">如何知道线程池中的任务已经执行完成✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#thread类中的yield方法有什么作用" class="sidebar-link">Thread类中的yield方法有什么作用</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#谈谈volatile的使用及其原理✔" class="sidebar-link">谈谈volatile的使用及其原理✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#如何创建线程实例并运行✔" class="sidebar-link">如何创建线程实例并运行✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程阻塞的三种情况" class="sidebar-link">线程阻塞的三种情况</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程死亡的三种方式" class="sidebar-link">线程死亡的三种方式</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#为什么我们调用start-方法时会执行run-方法-为什么我们不能直接调用run-方法" class="sidebar-link">为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#守护线程是什么✔" class="sidebar-link">守护线程是什么✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#了解fork-join框架吗" class="sidebar-link">了解Fork/Join框架吗</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#volatile" class="sidebar-link">Volatile</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#介绍一下java-memory-model-jmm" class="sidebar-link">介绍一下Java Memory Model（JMM）</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#可见性解决方案-synchronized、jmm、volatile" class="sidebar-link">可见性解决方案（synchronized、JMM、Volatile）</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#volatile为什么不能保证原子性-如何解决" class="sidebar-link">Volatile为什么不能保证原子性，如何解决</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#volatile如何保证有序性" class="sidebar-link">Volatile如何保证有序性</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#mesi缓存一致性协议-volatile保证可见性" class="sidebar-link">MESI缓存一致性协议（Volatile保证可见性）</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#volatile总结" class="sidebar-link">volatile总结</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#volatile和synchronized区别" class="sidebar-link">Volatile和Synchronized区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#synchronized" class="sidebar-link">synchronized</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#reentrantlock" class="sidebar-link">ReentrantLock</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程中并发锁" class="sidebar-link">线程中并发锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#cas了解吗-谈一下cas机制✔" class="sidebar-link">CAS了解吗，谈一下CAS机制✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#乐观锁和悲观锁" class="sidebar-link">乐观锁和悲观锁</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#cas有什么缺陷" class="sidebar-link">CAS有什么缺陷</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#请谈谈你对-volatile-的理解✔" class="sidebar-link">请谈谈你对 volatile 的理解✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#synchronized-和-volatile-的区别是什么✔" class="sidebar-link">synchronized 和 volatile 的区别是什么✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#synchronized-和-lock-有什么区别✔" class="sidebar-link">synchronized 和 Lock 有什么区别✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#synchronized-和-reentrantlock-区别是什么✔" class="sidebar-link">synchronized 和 ReentrantLock 区别是什么✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#synchronized的用法有哪些" class="sidebar-link">synchronized的用法有哪些</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#synchronized的作用有哪些-导致并发程序出现问题的根本原因是什么" class="sidebar-link">Synchronized的作用有哪些（导致并发程序出现问题的根本原因是什么）</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#说一下-synchronized-底层实现原理" class="sidebar-link">说一下 synchronized 底层实现原理</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#多线程中-synchronized-锁升级的原理是什么" class="sidebar-link">多线程中 synchronized 锁升级的原理是什么</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#synchronized-为什么是非公平锁-非公平体现在哪些地方" class="sidebar-link">synchronized 为什么是非公平锁？非公平体现在哪些地方</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#jvm对synchronized的优化有哪些" class="sidebar-link">JVM对synchronized的优化有哪些</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#synchronized-锁能降级吗" class="sidebar-link">synchronized 锁能降级吗</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#threadlocal是什么✔" class="sidebar-link">ThreadLocal是什么✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#threadlocal的实现原理✔" class="sidebar-link">ThreadLocal的实现原理✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#知道threadlocal-内存泄露问题吗" class="sidebar-link">知道ThreadLocal 内存泄露问题吗</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#threadlocal有哪些使用场景✔" class="sidebar-link">ThreadLocal有哪些使用场景✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#可重入锁及作用✔" class="sidebar-link">可重入锁及作用✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#了解reentrantlock吗✔" class="sidebar-link">了解ReentrantLock吗✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#readwritelock是什么" class="sidebar-link">ReadWriteLock是什么</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#你谈谈-jmm-java-内存模型" class="sidebar-link">你谈谈 JMM（Java 内存模型）</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#写一个会导致死锁的程序" class="sidebar-link">写一个会导致死锁的程序</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程池" class="sidebar-link">线程池</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#为什么要用线程池✔❕" class="sidebar-link">为什么要用线程池✔❕</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#执行execute-方法和submit-方法的区别是什么呢" class="sidebar-link">执行execute()方法和submit()方法的区别是什么呢</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#说下线程池核心参数✔" class="sidebar-link">说下线程池核心参数✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程池执行任务的流程-线程池底层threadpoolexecutor-实现原理-✔" class="sidebar-link">线程池执行任务的流程（ 线程池底层ThreadPoolExecutor 实现原理）✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#常用的java线程池有哪几种类型" class="sidebar-link">常用的JAVA线程池有哪几种类型</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程池常用的阻塞队列有哪些" class="sidebar-link">线程池常用的阻塞队列有哪些</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#基于数组的阻塞队列-arrayblockingqueue-原理" class="sidebar-link">基于数组的阻塞队列 ArrayBlockingQueue 原理</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#什么叫做阻塞队列的有界和无界✔" class="sidebar-link">什么叫做阻塞队列的有界和无界✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#源码中线程池是怎么复用线程的✔" class="sidebar-link">源码中线程池是怎么复用线程的✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#如何合理配置线程池参数" class="sidebar-link">如何合理配置线程池参数</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#如何确定核心线程数" class="sidebar-link">如何确定核心线程数</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#executor和executors的区别" class="sidebar-link">Executor和Executors的区别</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#为什么不建议用executors创建线程池" class="sidebar-link">为什么不建议用Executors创建线程池</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#aqs" class="sidebar-link">AQS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#说一说什么是aqs✔" class="sidebar-link">说一说什么是AQS✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#aqs使用了哪些设计模式" class="sidebar-link">AQS使用了哪些设计模式</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#了解aqs中同步队列的数据结构吗" class="sidebar-link">了解AQS中同步队列的数据结构吗</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#aqs为什么采用双向链表-而不是单向链表" class="sidebar-link">AQS为什么采用双向链表，而不是单向链表</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#了解aqs-对资源的共享方式吗" class="sidebar-link">了解AQS 对资源的共享方式吗</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#aqs-组件了解吗" class="sidebar-link">AQS 组件了解吗</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#atomic-原子类" class="sidebar-link">Atomic 原子类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#介绍一下-atomic-原子类" class="sidebar-link">介绍一下 Atomic 原子类</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#juc-包中的原子类是哪4类" class="sidebar-link">JUC 包中的原子类是哪4类</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#简单介绍一下-atomicinteger-类的原理" class="sidebar-link">简单介绍一下 AtomicInteger 类的原理</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#补充" class="sidebar-link">补充</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#为什么不建议使用executors创建线程" class="sidebar-link">为什么不建议使用Executors创建线程</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程池有几种状态" class="sidebar-link">线程池有几种状态</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#公平锁和非公平锁✔" class="sidebar-link">公平锁和非公平锁✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#说说对线程安全的理解✔" class="sidebar-link">说说对线程安全的理解✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#并发、并行、串行之间的区别✔" class="sidebar-link">并发、并行、串行之间的区别✔</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程池为什么是先添加队列而不是先创建最大线程" class="sidebar-link">线程池为什么是先添加队列而不是先创建最大线程</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#线程使用场景问题" class="sidebar-link">线程使用场景问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#如何控制某一个方法允许并发访问线程的数量" class="sidebar-link">如何控制某一个方法允许并发访问线程的数量</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#那该如何保证java程序在多线程的情况下执行安全呢" class="sidebar-link">那该如何保证Java程序在多线程的情况下执行安全呢</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#在项目中哪里用了多线程" class="sidebar-link">在项目中哪里用了多线程</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#其他" class="sidebar-link">其他</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#编写一个基于线程安全的懒加载单例模式" class="sidebar-link">编写一个基于线程安全的懒加载单例模式</a></li><li class="sidebar-sub-header"><a href="/interview-docs/my-docs/Interview/08-Java并发.html#伪共享的概念以及如何避免✔" class="sidebar-link">伪共享的概念以及如何避免✔</a></li></ul></li></ul></li><li><a href="/interview-docs/my-docs/Interview/09-JVM.html" class="sidebar-link">JVM</a></li><li><a href="/interview-docs/my-docs/Interview/数据结构与算法.html" class="sidebar-link">数据结构与算法</a></li><li><a href="/interview-docs/my-docs/Interview/校园行(Campus-trip).html" class="sidebar-link">校园行(Campus-trip)</a></li><li><a href="/interview-docs/my-docs/Interview/知识小站(Knowledge-Station).html" class="sidebar-link">知识小站(Knowledge-Station)</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java并发"><a href="#java并发" class="header-anchor">#</a> Java并发</h1> <h2 id="基础知识"><a href="#基础知识" class="header-anchor">#</a> 基础知识</h2> <h3 id="线程和进程有什么区别✔"><a href="#线程和进程有什么区别✔" class="header-anchor">#</a> 线程和进程有什么区别✔</h3> <ul><li>进程：是操作系统资源分配的基本单位</li> <li>线程：是处理器任务调度和执行的基本单位（轻量进程）</li></ul> <blockquote><p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</p> <p><strong>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程</strong>。</p> <p>一个进程之内可以分为一到多个线程。</p> <p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</p> <p>Java 中，<strong>线程作为最小调度单位，进程作为资源分配的最小单位</strong>。在 windows 中<strong>进程是不活动的，只是作为线程的容器</strong></p> <ul><li><strong>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</strong></li> <li><strong>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</strong></li> <li><strong>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</strong></li></ul></blockquote> <h3 id="创建线程的三种方式的对比✔"><a href="#创建线程的三种方式的对比✔" class="header-anchor">#</a> 创建线程的三种方式的对比✔</h3> <p>共有四种方式可以创建线程，分别是：继承Thread类、实现runnable接口、实现 Callable接口、线程池创建线程</p> <ul><li>1、实现Runnable接口</li> <li>2、实现Callable接口</li> <li>3、继承Thread类</li> <li>4、线程池创建线程</li></ul> <h3 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="header-anchor">#</a> 为什么要使用多线程呢</h3> <ul><li>轻量进程（和进程对比）
<ul><li>是程序执行的最小单位，线程的切换与调度成本远远小于进程</li></ul></li> <li>高并发系统
<ul><li>多线程是高并发系统的基础，提高系统整体的并发能力和性能。</li></ul></li></ul> <h3 id="线程的状态流转✔"><a href="#线程的状态流转✔" class="header-anchor">#</a> 线程的状态流转✔</h3> <p>线程的状态可以参考JDK中的Thread类中的枚举State</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>
    <span class="token comment">/**
        * 尚未启动的线程的线程状态
        */</span>
    <span class="token constant">NEW</span><span class="token punctuation">,</span>
    <span class="token comment">/**
        * 可运行线程的线程状态。处于可运行状态的线程正在 Java 虚拟机中执行，但它可能正在等待来自 
        * 操作系统的其他资源，例如处理器。
        */</span>
    <span class="token constant">RUNNABLE</span><span class="token punctuation">,</span>
    <span class="token comment">/**
        * 线程阻塞等待监视器锁的线程状态。处于阻塞状态的线程正在等待监视器锁进入同步块/方法或在调 
        * 用Object.wait后重新进入同步块/方法。
        */</span>
    <span class="token constant">BLOCKED</span><span class="token punctuation">,</span>
    <span class="token comment">/**
        * 等待线程的线程状态。由于调用以下方法之一，线程处于等待状态：
        * Object.wait没有超时
        * 没有超时的Thread.join
        * LockSupport.park
        * 处于等待状态的线程正在等待另一个线程执行特定操作。
        * 例如，一个对对象调用Object.wait()的线程正在等待另一个线程对该对象调用Object.notify() 
        * 或Object.notifyAll() 。已调用Thread.join()的线程正在等待指定线程终止。
        */</span>
    <span class="token constant">WAITING</span><span class="token punctuation">,</span>
    <span class="token comment">/*
        * 具有指定等待时间的等待线程的线程状态。由于以指定的正等待时间调用以下方法之一，线程处于定 
        * 时等待状态：
        * Thread.sleep
        * Object.wait超时
        * Thread.join超时
        * LockSupport.parkNanos
        * LockSupport.parkUntil
        * &lt;/ul&gt;
        */</span>
    <span class="token constant">TIMED_WAITING</span><span class="token punctuation">,</span>
    <span class="token comment">/**
        * 已终止线程的线程状态。线程已完成执行
        */</span>
    <span class="token constant">TERMINATED</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29617954/1678182403018-69f1a0f7-cdbb-453a-9dd3-1c45af3df473.png#averageHue=%23f4f4f4&amp;clientId=ub056d680-a9fb-4&amp;from=paste&amp;height=511&amp;id=u08465efa&amp;name=image.png&amp;originHeight=639&amp;originWidth=864&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=188643&amp;status=done&amp;style=none&amp;taskId=ub811b595-6d80-4618-aec3-efb4d3e0345&amp;title=&amp;width=691.2" alt="image.png"></p> <p><strong>1、新建（new）</strong></p> <p>当用new关键字创建一个线程时，还没调用start 就是新建状态。</p> <p><strong>2、就绪（runnable）</strong></p> <p>调用了 start 方法之后，线程就进入了就绪阶段。此时，线程不会立即执行run方法，需要等待获取CPU资源。</p> <p><strong>3、运行（Running）</strong></p> <p>当线程获得CPU时间片后，就会进入运行状态，开始执行run方法。</p> <p><strong>4、阻塞（Blocked）</strong></p> <p>调用sleep方法，使线程睡眠。</p> <p>调用wait方法，使线程进入等待。</p> <p>注意：阻塞状态只能进入就绪状态，不能直接进入运行状态。因为，从就绪状态到运行状态的切换是不受线程自己控制的，而是由线程调度器所决定。只有当线程获得了CPU时间片之后，才会进入运行状态。</p> <p><strong>5、死亡（Dead）</strong></p> <p>当run方法正常执行结束时，或者由于某种原因抛出异常都会使线程进入死亡状态。(或者调用stop)</p> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20230629110102621.png" alt="image-20230629110102621"></p> <h3 id="什么是线程死锁-如何避免死锁✔❕"><a href="#什么是线程死锁-如何避免死锁✔❕" class="header-anchor">#</a> 什么是线程死锁?如何避免死锁✔❕</h3> <p><strong>死锁</strong>：</p> <p>两个或多个线程相互等待对方释放资源而无法继续执行的一种状态，或者说去争夺同样一个共享资源造成的相互等待的一个现象。</p> <p>简单来说，当两个或多个线程无法继续执行，因为每个线程都在等待其他线程所占有的资源时，就会发生死锁。</p> <ul><li><p>多个线程同时被阻塞</p></li> <li><p>死锁原因：</p> <ul><li>1、互斥条件：共享资源X和Y每次只能被一个线程占用</li> <li>2、请求与保持条件：线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X</li> <li>3、不可抢占（剥夺）条件：其他线程不能强行抢占线程T1占有的资源</li> <li>4、循环等待条件：线程T1等待线程T2占有资源，线程T2等待线程T1占有的资源就是循环等待</li></ul> <p>导致死锁之后，只能通过人工干预来解决，重启服务或Kill掉这个线程</p></li> <li><p>如何避免</p> <p>只需要破坏死锁原因的四个条件之一就可以避免，互斥条件是互斥锁的基本约束，无法破坏</p> <ul><li>对于请求和保持条件：可以一次性申请所有的资源，就不存在锁要等待。在获取某个资源前，先释放已经持有的资源。</li> <li>对于不可抢占条件：占用资源的线程在进一步申请资源的时候，如果申请不到，可以主动是否释放占有的资源。如果一个线程等待时间过长，可以考虑强制剥夺它所持有的资源。</li> <li>对于循环等待条件：可以按照相同的顺序获取资源，或者使用资源请求的层级关系来避免循环等待，可以先申请资源小的在申请资源大的</li></ul> <hr> <ul><li><strong>注意死锁检查</strong>，这是一种预防机制，确保在第一时间发现死锁并进行解决</li> <li>使用超时机制：限制资源等待的时间，在一定时间内无法获得资源，则放弃或重试。</li></ul></li></ul> <h3 id="如何进行死锁诊断"><a href="#如何进行死锁诊断" class="header-anchor">#</a> 如何进行死锁诊断</h3> <p>第一：查看运行的线程</p> <div class="language-shell extra-class"><pre class="language-shell"><code>jps
</code></pre></div><p>第二：使用jstack查看线程运行的情况</p> <p>运行命令：<code>jstack -l 46032</code></p> <p><strong>其他解决工具，可视化工具</strong></p> <ul><li>jconsole</li></ul> <p>用于对jvm的内存，线程，类的监控，是一个基于 jmx 的 GUI 性能监控工具</p> <p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p> <ul><li>VisualVM：故障处理工具</li></ul> <p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对象，已被GC的对象，反向查看分配的堆栈</p> <p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p> <h3 id="concurrenthashmap-底层具体实现原理✔"><a href="#concurrenthashmap-底层具体实现原理✔" class="header-anchor">#</a> ConcurrentHashMap 底层具体实现原理✔</h3> <p>基本功能</p> <ul><li>本质是一个HashMap，在HashMap的基础上，提供了并发安全的一个实现，并发安全的主要实现，主要是通过对于Node节点去加锁来保证数据更新的安全性</li></ul> <p>性能方面的优化</p> <ul><li>引入红黑树，降低了数据查询的时间复杂度</li></ul> <p>ConcurrentHashMap 是一种线程安全的高效Map集合</p> <p>底层数据结构：</p> <ul><li><p>JDK1.7底层采用分段的数组+链表实现</p> <p>数据结构</p> <ul><li>提供了一个segment数组，在初始化ConcurrentHashMap 的时候可以指定数组的长度，默认是 16，一旦初始化之后中间不可扩容</li> <li>在每个segment中都可以挂一个HashEntry数组，数组里面可以存储具体的元素，HashEntry数组是可以扩容的</li> <li>在HashEntry存储的数组中存储的元素，如果发生冲突，则可以挂单向链表</li></ul> <p>存储流程</p> <ul><li>再通过hash值确定hashEntry数组中的下标存储数据</li> <li>在进行操作数据的之前，会先判断当前segment对应下标位置是否有线程进行操作，为了线程安全使用的是ReentrantLock进行加锁，如果获取锁是被会使用cas自旋锁进行尝试</li></ul></li> <li><p>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</p> <ul><li><p>当数组长度大于64，并且链表长度大于等于8 时候，单向链表就会转化成红黑树，一旦链表长度小于8，红黑树会退回成单向链表</p></li> <li><p>CAS控制数组节点的添加</p></li> <li><p>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题 , 效率得到提升</p></li></ul></li></ul> <h3 id="常见的对比✔"><a href="#常见的对比✔" class="header-anchor">#</a> 常见的对比✔</h3> <ul><li><p>1、<strong>Runnable VS Callable</strong></p> <ul><li>1）重写方法</li> <li>2）返回值
<ul><li>Runnable 接口run方法没有返回值；</li> <li>Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li></ul></li> <li>3）异常处理
<ul><li>call方法可以抛出异常</li> <li>run方法不可以抛出异常</li></ul></li></ul> <p>Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p></li> <li><p>2、Shutdown() VS shutdownNow() <strong>关闭线程池</strong></p> <ul><li>1）shutdown（）队列的任务得执行完毕</li> <li>2）shutdownNow（）	终止当前正在执行的任务</li></ul></li> <li><p>3、isTerminated() VS isShutdown()</p> <ul><li>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true</li></ul></li></ul> <h3 id="线程池中shutdown-和shutdownnow-方法的区别✔"><a href="#线程池中shutdown-和shutdownnow-方法的区别✔" class="header-anchor">#</a> 线程池中shutdown()和shutdownNow()方法的区别✔</h3> <p>shutdown() 和 shutdownNow() 这两个方法都是用来关闭线程池的</p> <p><strong>shutdown() 会使得线程池状态变为关闭状态，意味着不再接收新的任务，但是已提交的任务会继续执行，直到完成</strong>，因此shutdown() 并不会立即停止线程池中的工作线程，它只是停止了新任务的提交，一旦所有的任务都执行完成，线程池中的工作线程就会自动退出，它是一种优雅停止线程池的方法，在内部的实现中，线程池用到了AQS同步状态来判断当前是否有正在运行的线程</p> <p><strong>shutdownNow() 是尝试立即停止所有正在执行的任务</strong>，暂停等待的任务，并返回正在等待执行的任务列表，在内部的实现中，它是通过调用线程的interrupt方法来停止线程的，这个方法依赖于工作线程，对于这个中断的响应特性，不保证能立即停止正在执行的任务，但是会尽力去做，所有这个方法类似于一种暴力停机的实现</p> <p><strong>所以在实际开发中，尽可能使用shutdown() 去保证线程的优雅中断，来确保任务的完整性</strong></p> <h3 id="sleep-方法和-wait-方法区别和共同点✔"><a href="#sleep-方法和-wait-方法区别和共同点✔" class="header-anchor">#</a> sleep() 方法和 wait() 方法区别和共同点✔</h3> <p><strong><font color="blue">共同点</font></strong></p> <ul><li>wait()和sleep()这两个方法在并发编程中使用比较多，这两个方法都是让线程阻塞等待，但是等待的场景不一样</li> <li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul> <p>wait()方法通常与sychronized关键字一起使用，用于线程的同步和协作</p> <p>sleep()方法通常用于线程的等待，以便控制执行的时间间隔或实现简单的定时任务</p> <p><strong><font color="blue">不同点</font></strong></p> <p>1、<strong>方法归属不同</strong></p> <ul><li>wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li> <li>sleep(long) 是 Thread 的静态方法</li></ul> <p>2、<strong>用途不同</strong></p> <ul><li>wait()方法用于多个线程之间的协作通信</li> <li>sleep()方法用于线程的休眠</li></ul> <p>3、<strong>使用不同</strong></p> <ul><li>wait()方法必须在synchronized同步块中调用</li> <li>sleep()方法没有使用限制</li></ul> <p>4、<strong>醒来时机不同</strong></p> <ul><li>wait()方法会释放对象锁，使得当前线程进入等待状态，直到其他线程调用<strong>notify()或notifyAll()方法唤醒</strong>，如果不唤醒就一直等下去</li> <li>sleep()方法使当前线程暂停执行一段时间，不会释放对象锁</li></ul> <p>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</p> <p>它们都可以被打断唤醒</p> <p>5、<strong>锁特性不同（重点）</strong></p> <ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li> <li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li> <li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul> <p><strong>wait方法必须和synchronized配合使用</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WaitSleepCase</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">LOCK</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token function">sleeping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">illegalWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token constant">LOCK</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">waiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token constant">LOCK</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;t&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;waiting...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token constant">LOCK</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">5000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;t&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;interrupted...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;t1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token constant">LOCK</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            main<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;other...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sleeping</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token constant">LOCK</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;t&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;sleeping...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;t&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;interrupted...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;t1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token constant">LOCK</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            main<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;other...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="thread-sleep-0-有意义吗✔"><a href="#thread-sleep-0-有意义吗✔" class="header-anchor">#</a> Thread.sleep(0)有意义吗✔</h3> <p>Thread.sleep() 方法是Java线程调度的一部分，<strong>它让当前运行的线程暂停执行，并进入到阻塞状态，让出CPU的执行权</strong>，这个方法的底层是调用操作系统的sleep或者nanosleep系统调用，操作系统会把这个线程挂起，让出CPU的执行权给到其他线程或者进程，同时操作系统会设置一个定时器，当定时器到了以后，操作系统会再次唤醒这个线程，<strong>Thread.sleep(0) 这个调用虽然没有传递睡眠时长</strong>，<strong>但实际上还是会触发线程调度的切换</strong>，也就是说，<strong>当前线程会从运行状态变为就绪状态</strong>，然后操作系统调度器再根据优先级来选择一个线程执行，如果有优先级更高的线程正在等待CPU的时间片，那么这个线程就会得到执行，如果没有，那么可能就会立即再次选择刚刚进入就绪状态的这个线程来执行，具体的调度策略取决于操作系统层面的调度算法</p> <h3 id="线程的-run-和-start-有什么区别"><a href="#线程的-run-和-start-有什么区别" class="header-anchor">#</a> 线程的 run()和 start()有什么区别</h3> <ul><li><p>start(): <strong>用来启动线程，改变的是线程的状态</strong>，由就绪进入执行（运行），通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</p></li> <li><p>run(): <strong>封装了要被线程执行的代码，在执行（运行）状态时运行里面的代码</strong>，方法返回值是void，可以被调用多次。</p></li></ul> <h3 id="新建-t1、t2、t3-三个线程-如何保证它们按顺序执行✔"><a href="#新建-t1、t2、t3-三个线程-如何保证它们按顺序执行✔" class="header-anchor">#</a> 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行✔</h3> <p>在多线程中有多种方法让线程按特定顺序执行，<strong>你可以用线程类的join()方法在一个线程中启动另一个线程</strong>，另外一个线程完成该线程继续执行。</p> <p>举例：</p> <p>为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样 T1就会先完成而T3最后完成</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JoinTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建线程对象</span>
        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;t1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加入线程t1,只有t1线程执行完毕以后，再次执行该线程</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;t2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加入线程 t2,只有t2线程执行完毕以后，再次执行该线程</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;t3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token comment">// 启动线程</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="notify-和-notifyall-有什么区别✔"><a href="#notify-和-notifyall-有什么区别✔" class="header-anchor">#</a> notify()和 notifyAll()有什么区别✔</h3> <ul><li>notifyAll：唤醒所有wait的线程</li> <li>notify：只随机唤醒一个 wait 线程</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WaitNotify</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot;...wating...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot;...flag is true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot;...wating...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot;...flag is true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; hold lock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                lock<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h3 id="wait和notify为什么要在synchronized代码块中✔"><a href="#wait和notify为什么要在synchronized代码块中✔" class="header-anchor">#</a> wait和notify为什么要在synchronized代码块中✔</h3> <p>wait和notify是用来实现多个线程之间的协调，wait表示让线程进入阻塞状态，notify表示让阻塞的线程被唤醒，必然是成对出现的</p> <p>如果一个线程被wait方法阻塞了，那么必然需要另外一个线程通过notify()方法来唤醒，从而去实现多个线程之间的一个通信，有了synchronized同步锁，就可以实现对于多个通信线程之间的一个互斥，从而去实现条件等待和条件唤醒，另外为了避免wait/notify的错误使用，JDK强制要求把wait/notify写在了同步代码块里面</p> <h3 id="如何停止一个正在运行的线程"><a href="#如何停止一个正在运行的线程" class="header-anchor">#</a> 如何停止一个正在运行的线程</h3> <p>有三种方式可以停止线程</p> <ul><li>1、使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li> <li>2、使用stop方法强行终止（不推荐，方法已作废）</li> <li>3、使用interrupt方法中断线程</li></ul> <p>代码参考如下：</p> <p>① <strong>使用退出标志，使线程正常退出</strong>。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterrupt1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>

    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token punctuation">;</span>     <span class="token comment">// 线程执行的退出标记</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;MyThread...run...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>

        <span class="token comment">// 创建MyThread对象</span>
        <span class="token class-name">MyInterrupt1</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyInterrupt1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 主线程休眠6秒</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 更改标记为true</span>
        t1<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>② <strong>使用stop方法强行终止</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterrupt2</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>

    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token punctuation">;</span>     <span class="token comment">// 线程执行的退出标记</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;MyThread...run...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>

        <span class="token comment">// 创建MyThread对象</span>
        <span class="token class-name">MyInterrupt2</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyInterrupt2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 主线程休眠2秒</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 调用stop方法</span>
        t1<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>③ <strong>使用interrupt方法中断线程</strong>。</p> <div class="language-java extra-class"><pre class="language-java"><code>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterrupt3</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>

        <span class="token comment">//1.打断阻塞的线程</span>
        <span class="token comment">/*Thread t1 = new Thread(()-&gt;{
            System.out.println(&quot;t1 正在运行...&quot;);
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, &quot;t1&quot;);
        t1.start();
        Thread.sleep(500);
        t1.interrupt();
        System.out.println(t1.isInterrupted());*/</span>


        <span class="token comment">//2.打断正常的线程</span>
        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> current<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;打断状态：&quot;</span><span class="token operator">+</span>interrupted<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;t2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//        t2.interrupt();</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="如何知道线程池中的任务已经执行完成✔"><a href="#如何知道线程池中的任务已经执行完成✔" class="header-anchor">#</a> 如何知道线程池中的任务已经执行完成✔</h3> <p>在java中，有多种方法去判断线程池中的任务是否已经执行完成</p> <ul><li><p>1、使用<code>Future</code>对象，线程池有一个叫<code>submit()</code>方法，它会返回一个<code>Future</code>对象，我们可以通过<code>Future</code>的<code>isDone()</code>方法，来判断任务是否已经完成</p> <p>其次可以通过<code>Future.get()</code>方法，获得任务的执行结果，当线程池中的任务没有执行完之前，方法会一直阻塞，直到任务执行结束，只要方法正常返回，就意味着传入线程池中的任务已经执行完成了</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Executorservice</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPoo1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">Future</span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@override</span>
    pubic <span class="token keyword">void</span> run <span class="token punctuation">{</span>
        <span class="token comment">//任务内容</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> done <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>2、使用<code>CountDownLatch</code>计数器，<code>CountDownLatch</code>是一个同步工具类，可以在开始的时候，设置一个初始值，每个任务执行完成以后，调用<code>CountDownLatch</code>方法，把计数器减1，然后在主线程中调用<code>await()</code>方法，等待计数器归零，当计数器归零的时候，表示所有的任务已经完成了</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> taskcount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>taskcount<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Executorservice</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPoo1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> taskcount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//任务内容</span>
            <span class="token number">1</span>atch<span class="token punctuation">.</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//任务执行结束后，计数器减1</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token number">1</span>atch <span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待所有任务完成</span>

</code></pre></div></li> <li><p>使用线程池中的<code>ThreadPoolExecutor</code>的<code>isTerminated()</code>方法，当调用了线程池中的<code>shutdonw()</code>方法或者<code>shutdownNow()</code>方法以后，并且所有任务都已经执行完成以后，<code>isTerminated()</code>方法，会返回<code>true</code>，当然我们一般不会主动关闭线程，因此较少使用</p></li></ul> <p>不管是线程池内部还是外部，想要知道线程是否执行结束，必须要获取线程执行结束后的状态，而线程本身是没有返回值的，所以只能通过阻塞-唤醒的方式来实现</p> <h3 id="thread类中的yield方法有什么作用"><a href="#thread类中的yield方法有什么作用" class="header-anchor">#</a> Thread类中的yield方法有什么作用</h3> <ul><li>暂停当前正在执行的线程对象</li></ul> <h3 id="谈谈volatile的使用及其原理✔"><a href="#谈谈volatile的使用及其原理✔" class="header-anchor">#</a> 谈谈volatile的使用及其原理✔</h3> <ul><li>保证变量对所有线程的可见性</li></ul> <h3 id="如何创建线程实例并运行✔"><a href="#如何创建线程实例并运行✔" class="header-anchor">#</a> 如何创建线程实例并运行✔</h3> <p>共有四种方式可以创建线程，分别是：继承Thread类、实现runnable接口、实现 Callable接口、线程池创建线程</p> <p><strong>底层都是实现Runnable接口</strong></p> <ul><li>1、继承Thread类
<ul><li>重写<code>run()</code></li> <li>调用<code>new 类().start()</code></li></ul></li> <li>2、实现Runnable接口
<ul><li>重写<code>run()</code></li> <li>调用<code>new Thread( new 类() ).start()</code></li></ul></li> <li>3、实现Callable接口
<ul><li>重写<code>call()</code></li> <li><code>FuntureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(new 类() )</code></li> <li><code>new Thread(futureTask).start</code></li> <li>拿到call方法中的结果<code>futureTask.get()</code></li></ul></li> <li>4、创建线程池开启线程</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Execution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不建议</span>
        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//线程池会为我们开启一个线程</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre></div><h3 id="线程阻塞的三种情况"><a href="#线程阻塞的三种情况" class="header-anchor">#</a> 线程阻塞的三种情况</h3> <ul><li>1、等待阻塞
<ul><li>运行状态的线程执行<code>waitO()</code>方法后</li></ul></li> <li>2、同步阻塞
<ul><li>对象获取同步锁时，同步锁被其他线程占用，JVM将线程放入锁池中</li></ul></li> <li>3、其他阻塞</li></ul> <h3 id="线程死亡的三种方式"><a href="#线程死亡的三种方式" class="header-anchor">#</a> 线程死亡的三种方式</h3> <ul><li>正常结束</li> <li>异常结束</li> <li>调用stop</li></ul> <h3 id="为什么我们调用start-方法时会执行run-方法-为什么我们不能直接调用run-方法"><a href="#为什么我们调用start-方法时会执行run-方法-为什么我们不能直接调用run-方法" class="header-anchor">#</a> 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法</h3> <ul><li>在start（）中调用run（），会另起一个线程</li> <li>直接调用run（）会在主线程中执行，没有起到多线程的作用</li></ul> <h3 id="守护线程是什么✔"><a href="#守护线程是什么✔" class="header-anchor">#</a> 守护线程是什么✔</h3> <ul><li>运行在后台的一种特殊进程</li> <li>线程分为用户线程和守护线程，用户线程就是普通线程，守护线程就是JVM的后台线程</li></ul> <p>守护线程是专门为用户线程提供服务的线程，生命周期是依赖于用户线程的，只要JVM仍然存在用户线程正在运行的情况下，守护线程才会有存在的意义，否则一旦JVM进程结束，守护线程也会随之结束，也就是说守护线程不会阻止JVM的一个退出，但是用户线程会，守护线程和用户线程创建方式是完全一样的，我们只需要去调用用户线程里面的一个setDaemon方法设置成true就好，表示这个线程是守护线程</p> <h3 id="了解fork-join框架吗"><a href="#了解fork-join框架吗" class="header-anchor">#</a> 了解Fork/Join框架吗</h3> <ul><li>用于并行执行任务的框架</li> <li>是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架</li> <li>分而治之+工作窃取算法</li></ul> <h2 id="volatile"><a href="#volatile" class="header-anchor">#</a> Volatile</h2> <h3 id="介绍一下java-memory-model-jmm"><a href="#介绍一下java-memory-model-jmm" class="header-anchor">#</a> 介绍一下Java Memory Model（JMM）</h3> <p>Java内存模型是Java虚拟机规范中定义的一种内存模型规范，也就是说JMM知识一种规范，即标准化。不同的虚拟机厂商依据这套规范，来做底层具体的实现。了解这套规范，先从计算机内存模型开始聊起。</p> <p><font color="blue"><strong>计算机的内存模型</strong></font></p> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20240207120522741.png" alt="image-20240207120522741"></p> <p>从图中可以看到，CPU和内存之间加入了一个高速缓存的角色。在目前的计算机中，CPU的计算速度远远大于计算机存储的速度。为了提升整体性能，在CPU和内存之间加入了高速缓存。</p> <p>CPU将计算需要用到的数据暂存进缓存中。当计算结束后，再将缓存中的数据存入到内存中。这样CPU的运算可以在缓存中高速进行。</p> <p>但这种情况是在多核CPU中会存在一个问题，多个CPU使用各自的高速缓存，但多个高速缓存在共享同一内存，此时就有可能一个CPU更新了数据，但另一个CPU还在操作老数据。导致脏数据的读写问题，此时就需要缓存一致性协议来解决这个数据一致性的问题。</p> <p><font color="blue"><strong>JMM</strong></font></p> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20240207173652397.png" alt="image-20240207173652397"></p> <p>一段代码中的多线程，操作的共享变量，即成员变量或类变量。线程在操作共享变量时，先从主内存中将变量拷贝到工作内存中，然后线程在自己的工作内存中操作。线程不能访问别人工作内存中的内容。线程间对变量值的传递是通过主内存进行中转。这个操作就会导致可见性问题，即一个线程更新了共享变量，但另一个已经加载了数据到自己工作内存的线程，是没办法看到最新的变量的值。</p> <p>举例说明：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> flag<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;flag=&quot;</span> <span class="token operator">+</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyThread</span> myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>myThread<span class="token punctuation">.</span><span class="token function">isFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;here......&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token comment">//运行打印，结果表面：线程不能访问别人工作内存中的内容。线程间对变量值的传递是通过主内存进行中转。这个操作就会导致可见性问题</span>
flag<span class="token operator">=</span><span class="token boolean">true</span>
</code></pre></div><h3 id="可见性解决方案-synchronized、jmm、volatile"><a href="#可见性解决方案-synchronized、jmm、volatile" class="header-anchor">#</a> 可见性解决方案（synchronized、JMM、Volatile）</h3> <p><font color="blue"><strong>1、给代码加锁</strong></font></p> <p>例如上述例子</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyThread</span> myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//实现同步代码块效果</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>myThread<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>myThread<span class="token punctuation">.</span><span class="token function">isFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;here......&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><font color="blue"><strong>JMM数据同步</strong></font></p> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20240207183027935.png" alt="image-20240207183027935"></p> <p>上述例子没有使用解决可见性问题的数据同步执行流程：</p> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20240207184209218.png" alt="image-20240207184209218"></p> <ul><li>lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态（触发总线锁）</li> <li>unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li> <li>read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li> <li>Ioad(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li> <li>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li> <li>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量、</li> <li>store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</li> <li>write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li></ul> <p><font color="blue"><strong>2、使用JMM解决可见性问题</strong></font></p> <p>程序会按照上面的流程，<strong>在使用synchronized的代码前后，线程会获得锁，清空工作内存</strong>。read将数据读到工作内存并load成为最新的
副本，再通过store和write将数据写会主内存。而获取不到锁的线程会阻塞等待，所以变量的值一直都是最新的。</p> <p>在使用synchronized的代码前后，线程会获得锁，清空工作内存。MyThread线程（图中CPU核2）完成read、load、store、write，main线程（图中CPU核1）会从主内存中获得最新的数据，解决可见性问题。</p> <p><font color="blue"><strong>3、使用Volatile保证可见性</strong></font></p> <p>除了Synchronized外，Volatile也可以解决可见性问题</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo2</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyThread2</span> myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>myThread<span class="token punctuation">.</span><span class="token function">isFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;here......&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyThread2</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> flag<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;flag=&quot;</span> <span class="token operator">+</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用了Volatile后 ，操作数据的线程先从主内存中把数据读到自己的工作内存中。<strong>如果有线程对volatile修饰的变量进行操作并且写回了主内存，则其他已读取该变量的线程中，该变量副本将会失效。其他线程需要从主内存中加载一份最新的变量值。</strong></p> <p>Volatile保证了共享变量的可见性。当有的线程修改了Volatile修饰的变量值并写回到主内存后，其他线程能立即看到最新的值。</p> <p>但是Volatile不能保证原子性。</p> <h3 id="volatile为什么不能保证原子性-如何解决"><a href="#volatile为什么不能保证原子性-如何解决" class="header-anchor">#</a> Volatile为什么不能保证原子性，如何解决</h3> <p><strong>原子性问题的出现</strong>，看下面这个例子：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicityDemo1</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token class-name">Object</span> object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//创建CountDownLatch对象，值变成0之前可以让线程阻塞</span>
        <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">//值变成0之前可以让线程阻塞</span>
                    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">500</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        count<span class="token operator">++</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//值(1)-1 -&gt; 0 线程开始执行</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个例子中，并不会每次count的结果是5000，有的时候不足1000，于是做如下调整</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><p>当给变量count前加上了Volatile修饰后，发现结果依然有可能不足1000，看下<code>count++</code>的执行过程</p> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20240208205424614.png" alt="image-20240208205424614"></p> <p><code>count++</code>在执行引擎中被分成了两步操作：</p> <ul><li>1、<code>count=0</code>，先将count值初始化为0</li> <li>2、<code>count=count+1</code>，再执行+1的操作</li></ul> <p>这两步操作在左边的线程执行完第一步，但还没执行第二步时右边的线程抢过CPU控制器开始完成+1的操作后写入到主内存，<strong>由于volatile的可见性（当有一个线程有变化，会立即通知其他线程来更新工作内存，让接下来的多个操作失效，所以不能保证原子性）</strong>，于是左边的线程工作内存中的count副本失效了，相当于左边这一次+1的操作就被覆盖掉了</p> <p>因此，volatile不能保证原子性</p> <p><font color="blue"><strong>如何解决？——加锁</strong></font></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicityDemo1</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token class-name">Object</span> object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//创建CountDownLatch对象，值变成0之前可以让线程阻塞</span>
        <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>

                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">//值变成0之前可以让线程阻塞</span>
                    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">500</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">//加锁</span>
                        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">{</span>
                            count<span class="token operator">++</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//值(1)-1 -&gt; 0 线程开始执行</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h3 id="volatile如何保证有序性"><a href="#volatile如何保证有序性" class="header-anchor">#</a> Volatile如何保证有序性</h3> <p><strong>指令重排</strong>情况的出现</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RecorderDemo</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
            x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">shortWait</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待1秒</span>
                    a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                    x <span class="token operator">=</span> b<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span> thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">shortWait</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待1秒</span>
                    b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                    y <span class="token operator">=</span> a<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//t1线程执行完才能执行后续代码</span>
            thread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//t2线程执行完才能执行后续代码</span>
            <span class="token class-name">String</span> result <span class="token operator">=</span> <span class="token string">&quot;第&quot;</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">&quot;次:&quot;</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span> <span class="token operator">+</span> y<span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 延迟 interval 纳秒
     * @param interval
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shortWait</span><span class="token punctuation">(</span><span class="token keyword">long</span> interval<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> end<span class="token punctuation">;</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> interval <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
    <span class="token comment">/**
     * 输出
     * ...
     * 第40次:1,0
     * 第41次:0,1
     * 第42次:0,1
     * 第43次:0,1
     * 第44次:0,1
     * 第45次:1,1
     * ...
     */</span>
</code></pre></div><p>在这个例子中，x和y的值只会有三种情况：</p> <ul><li>1、x=1 y=1</li> <li>2、x=0 y=1</li> <li>3、x=1 y=0</li></ul> <p>如果发生指令重排，才会出现第四种：</p> <ul><li>x=0 y=0</li></ul> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20240209160020622.png" alt="image-20240209160020622"></p> <p>为了提高性能，编译器和处理器常常会对既定代码的执行顺序进行指令重排序</p> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20240209170103194.png" alt="image-20240209170103194"></p> <p>系统为了提升执行效率，在不影响最终结果的前提下，系统会对要求执行的指令进行重排序。</p> <p>重排序分为以下几种：</p> <ul><li>编译器优化的重排序：编译器在不改变单线程程序语义的前提下重新安排语句的执行顺序。</li> <li>指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li> <li>内存系统的重排序：由于数据读写过程涉及到多个缓冲区，这使得加载和存储的操作看上去可能是乱序执行，于是需要内存系统的重排序。</li></ul> <p><strong>as-if-seriali语义</strong></p> <p>不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守“as--if-serial语义&quot;。</p> <p>也就是说，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据
依赖关系，这些操作就可能被编译器和处理器重排序。</p> <p><strong>指令重排</strong>可能造成的问题：空指针，（将对象的创建过程进行指令重排，高并发时，可能返回对象的引用时，对象还未创建，导致空指针异常）</p> <p><font color="blue"><strong>使用volatile禁止指令重排</strong></font></p> <p>使用Volatile可以禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。<strong>Volatile通过设置内存屏障来解决指令重排优化</strong>。(Memory Barrier)</p> <p><strong>内存屏障</strong></p> <p>Java编译器会在生成指令系列时在适当的位置会插入“内存屏障指令”来禁止特定类型的处理器排序。下面是内存屏障指令：</p> <table><thead><tr><th>屏障类型</th> <th>指令示例</th> <th>说明</th></tr></thead> <tbody><tr><td>LoadLoad</td> <td>Load1;LoadLoad;Load2</td> <td>保证Load1操作在Load2之前执行</td></tr> <tr><td>StoreStore</td> <td>Store1;StoreStore;Store2</td> <td>在Store2及其后的写操作执行前，保证Store1的写操作已刷新到主内存</td></tr> <tr><td>LoadStore</td> <td>Load1;LoadStore;Store2</td> <td>在Store2及其后的写操作执行前，保证load1的读操作已经结束</td></tr> <tr><td>StoreLoad</td> <td>Store1;StoreLoad;Load</td> <td>保证Store1的写操作已经刷新到主内存之后，Load2及其后的读操作才能执行</td></tr></tbody></table> <p>如果在指令间插入了一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说<strong>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</strong>。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到数据的最新版本。总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。</p> <p>经典的懒汉式单例模式，可以被指令重排导致错误的结果</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>

    <span class="token comment">// 私有构造器</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//第一重检查锁定</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//同步锁定代码块</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment">//第二重检查锁定</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token comment">//注意：这里是非原子操作</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>如果在高并发场景下，因为<code>instance = new Singleton()</code>是非原子操作，这个对象的创建经历这么几个步骤：</p> <ul><li>分配内存空间</li> <li>通过构造器来初始化实例</li> <li>返回地址给引用</li></ul> <p>如果此时发生了指令重排，先执行了分配内存空间后直接返回地址给引用，再进行初始化。此时在这个过程中另一个线程抢占，虽然引用不为空，但对象还没有被实例化，于是报空指针异常。</p> <p>可以通过加入volatile来防止指令重排。</p> <div class="language-java extra-class"><pre class="language-java"><code>	<span class="token comment">//防止指令重排</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
</code></pre></div><p><strong>Volatile指令重排语义</strong></p> <p>为了实现Volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定排序规则</p> <p>Volatile重排序规则表：</p> <table><thead><tr><th style="text-align:left;">第一个操作</th> <th>第二个操作：普通读写</th> <th>第二个操作：volatile读</th> <th>第二个操作：volatile写</th></tr></thead> <tbody><tr><td style="text-align:left;">普通读写</td> <td>可以重排</td> <td><font color="blue">可以重排</font></td> <td>不可以重排</td></tr> <tr><td style="text-align:left;">Volatile读</td> <td>不可以重排</td> <td>不可以重排</td> <td>不可以重排</td></tr> <tr><td style="text-align:left;">Volatile写</td> <td><font color="blue">可以重排</font></td> <td>不可以重排</td> <td>不可以重排</td></tr></tbody></table> <p>这个规则在代码中体现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemoryBarrierDemo</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> m1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> m2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readAndWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> m1<span class="token punctuation">;</span><span class="token comment">//第一个volatile读</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> m2<span class="token punctuation">;</span><span class="token comment">//第二个volatile读</span>
        
        <span class="token comment">//相对来说 （普通写、Volatile读）可能造成指令重排</span>
        a <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span><span class="token comment">//普通写</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> m1<span class="token punctuation">;</span><span class="token comment">//第一个Volatile读</span>
        
        m1 <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//第一个Volatile写</span>
        m2 <span class="token operator">=</span> j <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//第二个volatile写</span>
        
        a <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span><span class="token comment">//普通写</span>
        
        <span class="token comment">// （volatile写、普通读） 可能造成指令重排</span>
        m1 <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//第一个Volatile写</span>
        a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">//普通读</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="mesi缓存一致性协议-volatile保证可见性"><a href="#mesi缓存一致性协议-volatile保证可见性" class="header-anchor">#</a> MESI缓存一致性协议（Volatile保证可见性）</h3> <p>在介绍Volatile保证可见性时，当两个线程在操作一个volatile修饰的变量时，操作数据的线程先从主内存中把数据读到自己的工作内存中。如果有线程对volatile修饰的变量进行操作并且写回了主内存，则其他已读取该变量的线程中，该变量副本将会失效。其他线程需要主内存中重新加载一份最新的变量值。</p> <p>那么被迫更新变量的线程是怎么知道操作的数据已被其他线程更新了呢？这就跟MESI缓存一致性协议有关系。</p> <p>早起技术较为落后，对总线上锁直接使用总线锁，也就是说CPU1访问到，CPU2一定不能操作， 总线锁并发性较差。MESI方式上锁是目前较为和谐的总线上锁的方式。</p> <p><img src="https://gitee.com/tjlxy/img/raw/master/image-20240214151837250.png" alt="image-20240214151837250"></p> <p>MESI协议缓存状态是四个单词的首字母：</p> <ul><li>M（Modified修改）：当CPU2对变量进行修改时，现在CPU内的缓存行中上锁，并向总线发信号，此时CPU2中的变量状态为M</li> <li>E（Exclusive独享）：当CPU1读取一个变量时，该变量在工作内存中的状态是E</li> <li>S（Shared共享）：当CPU2读取该变量时，两个CPU中该变量的状态由E转为S</li> <li>I（Invalid无效）：CPU1嗅探到变量被其他CPU修改的信号，于是将自己缓存行中的变量状态设置为i，即失效。则CPU再从内存中获取最新数据</li></ul> <p><strong>总线风暴</strong></p> <p>由于volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和CAS不断循环，无效交互导致总线带宽达到峰值。所以不要大量使用Volatile，至于什么时候去使用Volatile，什么时候使用锁，根据场景区分。</p> <h3 id="volatile总结"><a href="#volatile总结" class="header-anchor">#</a> volatile总结</h3> <p>volatile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如
booleanflag或者作为触发器，实现轻量级同步。</p> <p>volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁
和释放锁上，所以说它是低成本的。</p> <p>volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序。</p> <p>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主存中读取。</p> <p>volatile可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。</p> <h3 id="volatile和synchronized区别"><a href="#volatile和synchronized区别" class="header-anchor">#</a> Volatile和Synchronized区别</h3> <p>1、volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。</p> <p>2、volatile保证数据的可见性，但是不保证原子性（多线程进行写操作，不保证线程安全）；而synchronized是一种排他（互斥）的机制。volatile用于禁止指令重排序：可以解决单例双重检查对象初始化代码执行乱序问题。</p> <p>3、volatile可以看做是轻量版的synchronized,volatile不保证原子性，但是如果是对一个共享变量进行多个线程的赋值，而没有其他的操
作，那么就可以用volatile来代替synchronized,因为赋值本身是有原子性的，而volatile又保证了可见性，所以就可以保证线程安全了。</p> <h2 id="synchronized"><a href="#synchronized" class="header-anchor">#</a> synchronized</h2> <h2 id="reentrantlock"><a href="#reentrantlock" class="header-anchor">#</a> ReentrantLock</h2> <h2 id="线程中并发锁"><a href="#线程中并发锁" class="header-anchor">#</a> 线程中并发锁</h2> <h3 id="cas了解吗-谈一下cas机制✔"><a href="#cas了解吗-谈一下cas机制✔" class="header-anchor">#</a> CAS了解吗，谈一下CAS机制✔</h3> <p>CAS是Java中Unsafe类中里面的一个方法，全程是CompareAndSwap，<strong>主要功能是能够去保证在多线程的环境下，对于共享变量修改的一个原子性</strong>，在底层实现里面，如果是在多核的CPU环境下，会增加一个lock指令，来对缓存或者总线去加锁，从而去保证，比较并替换这两个操作的原子性，主要用在一些并发场景里面</p> <ul><li>比较并交换（Compare And Swap）它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性。</li></ul> <p>常用在以下两种</p> <p>1、在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作</p> <ul><li>AbstractQueuedSynchronizer（AQS框架）</li> <li>AtomicXXX类</li></ul> <p>2、实现多线程对共享资源竞争的互斥性质</p> <ul><li>AQS、ConcurrentHashMap，ConcurrentLinkedQueue</li></ul> <h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="header-anchor">#</a> 乐观锁和悲观锁</h3> <ul><li><p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p></li> <li><p>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p></li></ul> <h3 id="cas有什么缺陷"><a href="#cas有什么缺陷" class="header-anchor">#</a> CAS有什么缺陷</h3> <ul><li>ABA问题</li> <li>循环时间长开销</li> <li>只能保证一个变量的原子操作</li></ul> <h3 id="请谈谈你对-volatile-的理解✔"><a href="#请谈谈你对-volatile-的理解✔" class="header-anchor">#</a> 请谈谈你对 volatile 的理解✔</h3> <p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p> <ul><li><p>1、<strong>保证线程间的可见性</strong></p> <p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p></li> <li><p>2、<strong>禁止进行指令重排序</strong></p> <p>用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p></li></ul> <h3 id="synchronized-和-volatile-的区别是什么✔"><a href="#synchronized-和-volatile-的区别是什么✔" class="header-anchor">#</a> synchronized 和 volatile 的区别是什么✔</h3> <ul><li>synchronized解决的是执行控制的问题，阻止其他线程获取当前对象的监控锁</li> <li>volatile解决的是内存的可见性</li></ul> <h3 id="synchronized-和-lock-有什么区别✔"><a href="#synchronized-和-lock-有什么区别✔" class="header-anchor">#</a> synchronized 和 Lock 有什么区别✔</h3> <ul><li>1、特性层面
<ul><li>synchronized 是Java中的同步关键字，源码在 jvm 中，用 c++ 语言实现，用在方法，代码块上</li> <li>Lock 是JUC包里面提供的一个接口，源码由 jdk 提供，用 java 语言实现，用在代码块上</li> <li><strong>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁，可以判断是否成功获取到锁，Lock锁更加灵活</strong></li></ul></li> <li>2、功能层面
<ul><li>lock和syschronized都是Java中解决线程安全的一个工具，二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li> <li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li> <li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li> <li><strong>Lock提供了公平锁和非公平锁的机制 ，Synchronized只提供了一种非公平锁的实现</strong></li></ul></li> <li>性能层面
<ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，实现锁的优化</li> <li>在竞争激烈时，Lock 的实现通常会提供更好的性能，通过自旋锁实现性能优化</li></ul></li></ul> <h3 id="synchronized-和-reentrantlock-区别是什么✔"><a href="#synchronized-和-reentrantlock-区别是什么✔" class="header-anchor">#</a> synchronized 和 ReentrantLock 区别是什么✔</h3> <ul><li>都是可重入锁：一个线程中可以多次获取同一把锁</li> <li>依赖JVM和JDK Api</li> <li>后者更加高级。。</li> <li>如何选择（优先前者）</li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2023/png/29617954/1678452554553-29135f98-725b-498a-9ed1-3262779cb1bc.png#averageHue=%23f1f1f1&amp;clientId=uf6b2decf-7cc8-4&amp;from=paste&amp;height=372&amp;id=u975e4497&amp;name=image.png&amp;originHeight=465&amp;originWidth=1450&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=244167&amp;status=done&amp;style=none&amp;taskId=u4020a87c-2448-4b1d-90b7-8cee2b52950&amp;title=&amp;width=1160" alt="image.png"></p> <h3 id="synchronized的用法有哪些"><a href="#synchronized的用法有哪些" class="header-anchor">#</a> synchronized的用法有哪些</h3> <ul><li>修饰普通方法、静态方法、代码块</li></ul> <h3 id="synchronized的作用有哪些-导致并发程序出现问题的根本原因是什么"><a href="#synchronized的作用有哪些-导致并发程序出现问题的根本原因是什么" class="header-anchor">#</a> Synchronized的作用有哪些（导致并发程序出现问题的根本原因是什么）</h3> <ul><li><p>1、原子性</p> <p>一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行</p> <p>解决方案：</p> <ul><li><p>1）synchronized：同步加锁</p></li> <li><p>2）JUC里面的lock：加锁</p></li></ul></li> <li><p>2、可见性</p> <p>内存可见性：让一个线程对共享变量的修改对另一个线程可见</p> <p>解决方案：</p> <ul><li><p>1）synchronized</p></li> <li><p>2）volatile（推荐）</p></li> <li><p>3）LOCK</p></li></ul></li> <li><p>2、有序性</p> <p>指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p> <p>解决方案：</p> <ul><li>volatile</li></ul></li></ul> <h3 id="说一下-synchronized-底层实现原理"><a href="#说一下-synchronized-底层实现原理" class="header-anchor">#</a> 说一下 synchronized 底层实现原理</h3> <p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p> <table><thead><tr><th></th> <th><strong>描述</strong></th></tr></thead> <tbody><tr><td>重量级锁</td> <td>底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</td></tr> <tr><td>轻量级锁</td> <td>线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td></tr> <tr><td>偏向锁</td> <td>一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark  word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</td></tr></tbody></table> <p><strong>一旦锁发生了竞争，都会升级为重量级锁</strong></p> <h3 id="多线程中-synchronized-锁升级的原理是什么"><a href="#多线程中-synchronized-锁升级的原理是什么" class="header-anchor">#</a> 多线程中 synchronized 锁升级的原理是什么</h3> <p>在Java中，synchronized关键字用于实现线程之间的同步，确保多个线程对共享资源的访问具有原子性和可见性。在JVM中，synchronized锁的升级过程主要包括无锁、偏向锁、轻量级锁和重量级锁。</p> <ul><li><p>1、无锁状态：当一个线程访问一个没有被锁定的同步块时，不需要进行任何同步操作，可以直接执行。</p></li> <li><p>2、偏向锁：当一个线程访问一个同步块时，会使用CAS操作将对象头中的标记位设置为偏向锁，并将线程ID记录在对象头中。如果后续再有其他线程访问该同步块，会先检查对象头中的线程ID是否与当前线程ID相同，如果相同，则直接执行同步块；如果不同，则撤销偏向锁，升级为轻量级锁。</p></li> <li><p>3、轻量级锁：如果偏向锁失败，即有多个线程竞争同一个锁时，JVM会将对象头中的信息复制到线程栈帧中的锁记录（Lock Record）中，并尝试使用CAS操作将对象头替换为指向锁记录的指针。如果CAS操作成功，线程可以继续执行同步块；如果失败，说明有其他线程竞争锁，升级为重量级锁。</p></li> <li><p>4、重量级锁：当轻量级锁失败时，JVM会使用互斥量来保护同步块，即将对象的状态升级为重量级锁。此时，其他线程需要进入阻塞状态，并且操作系统会对阻塞的线程进行调度，直到获取到锁的线程释放锁。</p></li></ul> <p>锁的升级过程主要是为了提供更高效的同步机制。在多线程竞争不激烈的情况下，偏向锁和轻量级锁可以减少线程间的竞争，提高程序的执行效率。只有当竞争激烈时，才会升级为重量级锁来保证线程的安全性。这种锁的升级机制可以根据实际情况在不同的同步场景中提供更好的性能表现。</p> <h3 id="synchronized-为什么是非公平锁-非公平体现在哪些地方"><a href="#synchronized-为什么是非公平锁-非公平体现在哪些地方" class="header-anchor">#</a> synchronized 为什么是非公平锁？非公平体现在哪些地方</h3> <ul><li>当线程尝试获取锁失败，进入阻塞时，放入链表的顺序，和最终被唤醒的顺序是不一致的</li></ul> <h3 id="jvm对synchronized的优化有哪些"><a href="#jvm对synchronized的优化有哪些" class="header-anchor">#</a> JVM对synchronized的优化有哪些</h3> <ul><li>锁膨胀</li> <li>锁消除</li> <li>锁粗化</li> <li>自旋锁与自适应自旋锁</li></ul> <h3 id="synchronized-锁能降级吗"><a href="#synchronized-锁能降级吗" class="header-anchor">#</a> synchronized 锁能降级吗</h3> <ul><li>可以的，执行清理任务的时候会尝试降级锁</li></ul> <h3 id="threadlocal是什么✔"><a href="#threadlocal是什么✔" class="header-anchor">#</a> ThreadLocal是什么✔</h3> <ul><li>线程本地变量</li> <li>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量， 从而起到线程隔离的作用，避免了线程安全问题。</li></ul> <p>ThreadLocal 主要功能有两个，第一个是可以实现资源对象的线程隔离，让每个线程各用各的资源对象，<strong>避免争用引发的线程安全问题</strong>，第二个是实现了<strong>线程内的资源共享</strong>。</p> <h3 id="threadlocal的实现原理✔"><a href="#threadlocal的实现原理✔" class="header-anchor">#</a> ThreadLocal的实现原理✔</h3> <ul><li>Thread对象中持有一个ThreadLocalMap  的实例变量 threadLocals</li> <li>ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型值</li></ul> <p>在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p> <p>当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</p> <p>当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</p> <p>当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</p> <h3 id="知道threadlocal-内存泄露问题吗"><a href="#知道threadlocal-内存泄露问题吗" class="header-anchor">#</a> 知道ThreadLocal 内存泄露问题吗</h3> <ul><li>弱引用（只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象）
<ul><li>ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，ThreadLocalMap的key没了，value还在 ，造成内存泄露</li></ul></li></ul> <blockquote><p>是因为ThreadLocalMap 中的 <strong>key 被设计为弱引用</strong>，它是被动的被GC调用释放key，不过关键的是只有key可以得到内存释放，而value不会，因为<strong>value是一个强引用</strong>。</p> <p>在使用ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。</p></blockquote> <h3 id="threadlocal有哪些使用场景✔"><a href="#threadlocal有哪些使用场景✔" class="header-anchor">#</a> ThreadLocal有哪些使用场景✔</h3> <p>ThreadLocal是可以基于副本的隔离机制来<strong>保证共享变量的安全性</strong>，以下是几种常见的使用场景</p> <ul><li><p>1、线程的上下文传递</p> <p>在跨线程调用的场景中，可以使用ThreadLocal在不修改方法签名的情况下传递线程上下文信息，比如框架和中间件里面，把请求的相关信息，比如用户信息、请求id信息等等，存储在ThreadLocal里面，在后续的请求处理链路中，都可以方便的去访问这些信息</p></li> <li><p>2、数据库的连接管理</p> <p>在使用数据库连接池的情况下，可以把数据库的连接存储在ThreadLocal里面，这样每个线程可以独立管理自己的数据库连接，避免了线程之间的竞争和冲突，比如Mybatis中的SqlSession对象，使用了ThrashLocal来存储当前线程的数据库会话信息</p></li> <li><p>3、事务管理</p> <p>在一些需要手动管理事务的场景中，可以使用ThreadLocal来存储事务上下文，每个线程可以独立的控制自己的事务，保证事务的隔离性，Spring中的TransactionSynchronizeManager类，就使用了ThreadLocal来存储事务相关的上下文信息，不过在使用ThreadLocal的时候，需要注意使用规范，避免出现内存泄露的问题</p></li></ul> <h3 id="可重入锁及作用✔"><a href="#可重入锁及作用✔" class="header-anchor">#</a> 可重入锁及作用✔</h3> <p>简单来说在运行的某个函数或者代码因为抢占资源或者中断导致这个函数或者代码运行过程中被中断了，那么等到中断的程序执行结束以后，重新进入到这个函数的代码里面，再运行的时候，并且运行的结果不会发生变化，那么这个函数或者代码就是可重入的。</p> <p>可重入锁就是一个线程如果抢占到了互斥锁的资源，在锁释放之前，再去竞争同一把锁的时候，不需要等待，只需要去记录重试次数，在多线程并发编程里面，大多数的锁都是可重入的，比如Synchronized，ReentrantLock。主要解决问题是避免死锁的问题，</p> <h3 id="了解reentrantlock吗✔"><a href="#了解reentrantlock吗✔" class="header-anchor">#</a> 了解ReentrantLock吗✔</h3> <p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p> <ul><li>可中断、可重入</li> <li>可以设置超时时间</li> <li>可以设置公平锁，支持非公平锁</li> <li>支持多个条件变量</li> <li>与synchronized一样，都支持重</li></ul> <p>ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似</p> <p>构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p> <ul><li>ReentrantLock 是在<strong>多线程竞争资源</strong>时使用的锁，他是一个独占锁、可重入锁，也是悲观锁</li> <li>ReentrantLock 支持公平锁，对公平和非公平锁有不同的实现逻辑</li> <li>ReentrantLock  使用 aqs（AbstractQueuedSynchronizer）来实现的获取锁的线程队列等待的过程</li> <li>内部使用了原子操作类 cas 比较线程与对应的锁关系</li> <li>内部支持newCondition来灵活的控制获取到锁的线程的阻塞与释放</li></ul> <h3 id="readwritelock是什么"><a href="#readwritelock是什么" class="header-anchor">#</a> ReadWriteLock是什么</h3> <ul><li>读写锁接口</li></ul> <h3 id="你谈谈-jmm-java-内存模型"><a href="#你谈谈-jmm-java-内存模型" class="header-anchor">#</a> 你谈谈 JMM（Java 内存模型）</h3> <p>JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。</p> <p>Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节</p> <p>特点：</p> <ul><li><p>1、所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p></li> <li><p>2、每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p></li> <li><p>3、线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。</p></li></ul> <h3 id="写一个会导致死锁的程序"><a href="#写一个会导致死锁的程序" class="header-anchor">#</a> 写一个会导致死锁的程序</h3> <ol><li>获得锁后不释放，其他线程一直拿不到锁</li> <li>解决：不要嵌套获得多个锁</li></ol> <div class="language-java extra-class"><pre class="language-java"><code>
<span class="token keyword">static</span> <span class="token class-name">Object</span> lockA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token class-name">Object</span> lockB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 尝试获取锁A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockA<span class="token punctuation">)</span><span class="token punctuation">{</span>

                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 获取到了锁A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 尝试获取锁B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockB<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 获取到了锁B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 尝试获取锁B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockB<span class="token punctuation">)</span><span class="token punctuation">{</span>

                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 获取到了锁B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 尝试获取锁A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockA<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 获取到了锁A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
</code></pre></div><h2 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h2> <h3 id="为什么要用线程池✔❕"><a href="#为什么要用线程池✔❕" class="header-anchor">#</a> 为什么要用线程池✔❕</h3> <ul><li><p>因为频繁的开启线程或者停止线程，线程需要重新被CPU从就绪到运行状态调度，需要发生CPU的上下文切换，效率非常低</p></li> <li><p>线程池是复用机制，提前创建好一些固定的线程数一直在运行状态，实现复用，从而可以减少就绪到运行状态的切换</p></li></ul> <p><strong>线程池的作用：</strong></p> <ul><li>1、降低资源消耗</li> <li>2、提高响应速度</li> <li>3、提高系统的可管理性</li> <li>4、提供更多强大的功能：线程池具备可扩展性，允许开发人员向其中增加更多的功能。如延时定时线程池</li></ul> <h3 id="执行execute-方法和submit-方法的区别是什么呢"><a href="#执行execute-方法和submit-方法的区别是什么呢" class="header-anchor">#</a> 执行execute()方法和submit()方法的区别是什么呢</h3> <ul><li>execute：用于提交无返回值的任务</li> <li>submit：用于提交有返回值的任务</li></ul> <h3 id="说下线程池核心参数✔"><a href="#说下线程池核心参数✔" class="header-anchor">#</a> 说下线程池核心参数✔</h3> <ul><li><code>corePoolSize</code>：核心线程大小，一直正在保存运行的线程</li> <li><code>maximumPoolSize</code>线程池最大线程数，（线程池运行创建的最大线程数） = (核心线程+救急线程的最大数目)</li> <li><code>KeepAliveTime</code>非核心线程的心跳时间，（超出corePoolSize后创建的线程的存活时间，默认60s，超过时间没有任务执行就会停掉超过时间的线程，所有说线程池创建的线程并不会一直在运行状态）</li> <li><code>workQueue</code>阻塞队列，存放线程池的任务，（阻塞队列，保存待执行的任务）</li> <li><code>defaultHandler</code>饱和策略</li> <li><code>ThreadFactory</code>线程工厂（线程内部创建线程所有的工厂）</li> <li><code>handler</code>任务无法执行时的处理器，workQueue 也放满时，会触发拒绝策略</li> <li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li></ul> <h3 id="线程池执行任务的流程-线程池底层threadpoolexecutor-实现原理-✔"><a href="#线程池执行任务的流程-线程池底层threadpoolexecutor-实现原理-✔" class="header-anchor">#</a> 线程池执行任务的流程（ 线程池底层ThreadPoolExecutor 实现原理）✔</h3> <p>实际上最多执行多少个任务：核心线程数+缓存队列的容量+最大线程数-核心线程数</p> <ul><li>1、当线程数小于核心线程数时，创建线程。</li> <li>2、当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。</li> <li>3、当线程数大于等于核心线程数，且任务队列已满
<ul><li>1）若线程数小于最大线程数，创建线程</li> <li>2）若线程数等于最大线程数，抛出异常，拒绝任务</li></ul></li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2023/png/29617954/1675158850882-ebaaeb4c-138e-46d3-ad5f-21225ac2dda8.png#averageHue=%23f7f4f2&amp;clientId=ub07cf81e-dc25-4&amp;from=paste&amp;height=590&amp;id=u071e20a9&amp;name=image.png&amp;originHeight=737&amp;originWidth=892&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=103312&amp;status=done&amp;style=none&amp;taskId=u1cd264e8-a421-4667-a2cc-8b9297994dd&amp;title=&amp;width=713.6" alt="image.png"></p> <h3 id="常用的java线程池有哪几种类型"><a href="#常用的java线程池有哪几种类型" class="header-anchor">#</a> 常用的JAVA线程池有哪几种类型</h3> <ul><li><code>newCachedThreadPool</code>可缓存线程池
<ul><li>可灵活回收空闲线程，</li> <li>线程创建数量几乎没有限制</li></ul></li> <li><code>newFixedThreadPool</code>创建一个指定工作线程数量的线程池
<ul><li>不用释放工作线程，会占用一定的系统资源</li></ul></li> <li><code>newSingleThreadExecutor</code>创建一个单线程化的Executor
<ul><li>顺序执行各个任务（FIFO）</li></ul></li> <li><code>newSchedulerThreadPool</code>创建一个定长的线程池
<ul><li>支持定时及周期性任务执行</li></ul></li></ul> <h3 id="线程池常用的阻塞队列有哪些"><a href="#线程池常用的阻塞队列有哪些" class="header-anchor">#</a> 线程池常用的阻塞队列有哪些</h3> <p><img src="https://cdn.nlark.com/yuque/0/2023/png/29617954/1680490088943-924c71f1-dfe2-4060-8ed9-41092308619d.png#averageHue=%23fbfdfc&amp;clientId=u37fba2b1-9588-4&amp;from=paste&amp;height=350&amp;id=u3121adac&amp;name=image.png&amp;originHeight=437&amp;originWidth=966&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=81077&amp;status=done&amp;style=none&amp;taskId=u9e06232b-27e1-4376-b93a-a23906ee203&amp;title=&amp;width=772.8" alt="image.png"></p> <p>比较常见的有4个，用的最多是ArrayBlockingQueue和LinkedBlockingQueue</p> <p>1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。</p> <p>2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。</p> <p>3.DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</p> <p>4.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p> <p><strong>ArrayBlockingQueue的LinkedBlockingQueue区别</strong></p> <table><thead><tr><th><strong>LinkedBlockingQueue</strong></th> <th><strong>ArrayBlockingQueue</strong></th></tr></thead> <tbody><tr><td>默认无界，支持有界</td> <td>强制有界</td></tr> <tr><td>底层是链表</td> <td>底层是数组</td></tr> <tr><td>是懒惰的，创建节点的时候添加数据</td> <td>提前初始化 Node  数组</td></tr> <tr><td>入队会生成新 Node</td> <td>Node需要是提前创建好的</td></tr> <tr><td>两把锁（头尾）</td> <td>一把锁</td></tr></tbody></table> <h3 id="基于数组的阻塞队列-arrayblockingqueue-原理"><a href="#基于数组的阻塞队列-arrayblockingqueue-原理" class="header-anchor">#</a> 基于数组的阻塞队列 ArrayBlockingQueue 原理</h3> <p>阻塞队列是在队列的基础上去增加了两个附加操作，第一个是队列为空的时候，获取元素的线程会等待队列变为非空，当队列满了的时候，存储元素的线程会等待队列为可用，由于这样一个特性，非常容易实现生产者和消费者这样一个模型，如果队列满了，生产者就等待，队列空了消费者等待</p> <ul><li><p>队列元素的存储：循环数组</p></li> <li><p>线程阻塞和唤醒：ReetrantLock 和 Condition</p></li></ul> <h3 id="什么叫做阻塞队列的有界和无界✔"><a href="#什么叫做阻塞队列的有界和无界✔" class="header-anchor">#</a> 什么叫做阻塞队列的有界和无界✔</h3> <p>阻塞队列是一种特殊的队列，它在普通队列的基础上提供了两种附加的功能。</p> <p>第一，当队列为空的时候，获取队列中元素的消费者线程它会被阻塞，同时会唤醒生产者线程。</p> <p>第二，当队列中的元素满了的时候，向队列中去添加元素的生产者线程会被阻塞，同时会唤醒消费者线程，其中，阻塞队列中能够容纳的元素个数通常情况下是有限的，比如说我们去实例化一个<code>ArrayBlockinglist</code>可以在构造方法中去传入一个整形的数字，表示这个基于数组的阻塞队列中，能够容纳的元素个数，这种称为有界队列。</p> <p>第三，而无界队列就是没有设置固定大小的队列，并不是元素中没有任何限制，而是它的元素存储量很大，像<code>LinkedBlockingQueue</code>，它的默认队列长度是<code>Integer.Max.Value</code>，所有感知不到它的长度限制。无界队列存在比较大的潜在风险，如果在并发量比较大的情况下，线程池中几乎可以无限制的添加任务，容易导致内存溢出的问题</p> <h3 id="源码中线程池是怎么复用线程的✔"><a href="#源码中线程池是怎么复用线程的✔" class="header-anchor">#</a> 源码中线程池是怎么复用线程的✔</h3> <p>线程池里面采用了一个生产者消费者的模式呢，去实现线程的一个复用，生产者消费者模型其实就是通过一个中间容器，来取解耦生产者和消费者的一个任务处理的过程，生产者不断生产任务保存到容器里面，消费者不断从容器里面去消费任务。</p> <p>在线程池里面，因为需要去保证工作线程的一个重复使用，并且这些线程呢，应该是有任务处理的时候执行，没有任务的时候要等待，并且是否CPU资源，所有使用了<strong>阻塞队列</strong>来实现这样一个需求，提交任务到线程池里面的一个线程称为生产者线程，他不断的去往线程池里面去传递任务，这些任务会保存在线程池里的一个阻塞队列里面，然后线程池里面的工作线程不断的去阻塞队列获取任务去执行，基于阻塞队列这样一个特性，<strong>如果队列里面没有任务执行的时候，这些工作线程就会阻塞等待，直到又有新的任务进来的时候，这些工作线程又再次被唤醒，从而达到线程复用</strong></p> <p><img src="https://gitee.com/tjlxy/img/raw/master/1678185487298-87e8d2c1-9ba2-461e-9ef8-d6571fa3ea1c.png" alt="image.png"></p> <ul><li>源码中ThreadPoolExecutor中有个内置对象Worker，每个worker都是一个线程</li> <li>通过置换worker中Runnable对象，运行其run方法起到线程置换的效果</li></ul> <h3 id="如何合理配置线程池参数"><a href="#如何合理配置线程池参数" class="header-anchor">#</a> 如何合理配置线程池参数</h3> <ul><li>CPU密集型：需要最大运算，没有阻塞，CPU一直全速运行</li> <li>IO密集型：需要大量IO，即大量的阻塞，大部分线程被阻塞，需要多配置线程数</li></ul> <h3 id="如何确定核心线程数"><a href="#如何确定核心线程数" class="header-anchor">#</a> 如何确定核心线程数</h3> <p>在设置核心线程数之前，需要先熟悉一些执行线程池执行任务的类型</p> <ul><li><strong>IO密集型任务</strong></li></ul> <p>一般来说：文件读写、DB读写、网络请求等</p> <p>推荐：核心线程数大小设置为2N+1    （N为计算机的CPU核数）</p> <ul><li><strong>CPU密集型任务</strong></li></ul> <p>一般来说：计算型代码、Bitmap转换、Gson转换等</p> <p>推荐：核心线程数大小设置为N+1    （N为计算机的CPU核数）</p> <h3 id="executor和executors的区别"><a href="#executor和executors的区别" class="header-anchor">#</a> Executor和Executors的区别</h3> <ul><li><code>Executor</code> <ul><li>接口</li></ul></li> <li><code>Executors</code> <ul><li>工具类</li></ul></li></ul> <h3 id="为什么不建议用executors创建线程池"><a href="#为什么不建议用executors创建线程池" class="header-anchor">#</a> 为什么不建议用Executors创建线程池</h3> <p>其实这个事情在阿里提供的最新开发手册《Java开发手册-嵩山版》中也提到了</p> <p>主要原因是如果使用Executors创建线程池的话，它允许的请求队列默认长度是Integer.MAX_VALUE，这样的话，有可能导致堆积大量的请求，从而导致<strong>OOM</strong>（内存溢出）。</p> <p>所以，我们一般推荐使用ThreadPoolExecutor来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。</p> <h2 id="aqs"><a href="#aqs" class="header-anchor">#</a> AQS</h2> <h3 id="说一说什么是aqs✔"><a href="#说一说什么是aqs✔" class="header-anchor">#</a> 说一说什么是AQS✔</h3> <ul><li><p>AQS是一个锁框架，它定义了锁的实现机制，并开放出扩展的地方，让子类去实现</p> <p>全称是 AbstractQueuedSynchronizer，是JUC包下面Lock锁的底层实现，是阻塞式锁和相关的同步器工具的框架，它是构建锁或者其他同步组件的基础框架</p></li></ul> <p><strong>AQS与Synchronized的区别</strong></p> <table><thead><tr><th><strong>synchronized</strong></th> <th><strong>AQS</strong></th></tr></thead> <tbody><tr><td>关键字，c++ 语言实现</td> <td>java  语言实现</td></tr> <tr><td>悲观锁，自动释放锁</td> <td>悲观锁，手动开启和关闭</td></tr> <tr><td>锁竞争激烈都是重量级锁，性能差</td> <td>锁竞争激烈的情况下，提供了多种解决方案</td></tr></tbody></table> <p>AQS常见的实现类</p> <ul><li><p>ReentrantLock      阻塞式锁</p></li> <li><p>Semaphore        信号量</p></li> <li><p>CountDownLatch   倒计时锁</p></li></ul> <h3 id="aqs使用了哪些设计模式"><a href="#aqs使用了哪些设计模式" class="header-anchor">#</a> AQS使用了哪些设计模式</h3> <p>AbstractQueuedSynchronizer (AQS) 是Java中用于实现同步器的基础框架，它使用了一些设计模式来支持不同类型的同步机制。以下是AQS使用的几种常见的设计模式：</p> <ul><li><p>1、模板方法模式（Template Method Pattern）：AQS使用了模板方法模式来定义同步器的骨架结构。AQS提供了一个模板方法<code>acquire</code>和<code>release</code>，具体的同步器可以通过继承AQS，并实现自己的逻辑来完成对资源的获取和释放。AQS在模板方法中定义了同步的整体流程，并留出了钩子方法（hook method）供具体的实现类来覆盖。</p></li> <li><p>2、观察者模式（Observer Pattern）：AQS使用了观察者模式来管理线程的等待队列。当一个线程尝试获取锁而被阻塞时，它会被添加到同步器的等待队列中。当其他线程释放锁时，AQS会通知等待队列中的线程，使它们有机会重新竞争锁。</p></li> <li><p>3、策略模式（Strategy Pattern）：AQS使用了策略模式来支持不同类型的同步机制。AQS将同步器的具体行为委托给了一个Sync类，而Sync类可以根据同步器的需要选择不同的策略来实现同步逻辑。AQS提供了公平锁和非公平锁两种策略的实现，默认使用非公平锁。</p></li> <li><p>4、回调模式（Callback Pattern）：AQS使用了回调模式来通知等待线程的状态变化。具体来说，当一个线程被阻塞时，它会调用Sync对象的<code>shouldParkAfterFailedAcquire</code>方法来判断是否需要阻塞自己。而这个方法内部会调用一个回调函数<code>parkAndCheckInterrupt</code>来实际执行阻塞操作。</p></li></ul> <p>这些设计模式的使用使得AQS能够灵活地支持不同的同步机制，并提供了可扩展性和可定制性。通过继承AQS并实现自己的同步器，开发人员可以根据需求来定义自己的同步逻辑。</p> <h3 id="了解aqs中同步队列的数据结构吗"><a href="#了解aqs中同步队列的数据结构吗" class="header-anchor">#</a> 了解AQS中同步队列的数据结构吗</h3> <p>AQS使用一个<strong>双向链表</strong>来作为同步队列，该链表主要用于管理等待获取资源的线程。</p> <p>在AQS中，同步队列的节点被定义为Node类。每个Node对象代表一个等待获取资源的线程，并包含了线程相关的信息。</p> <p>Node类的主要字段包括：</p> <ul><li><code>prev</code>：指向前一个节点的引用。</li> <li><code>next</code>：指向后一个节点的引用。</li> <li><code>thread</code>：表示关联的线程。</li> <li><code>status</code>：表示节点的状态，如CANCELLED（已取消）、SIGNAL（需要唤醒）等。</li> <li><code>waitStatus</code>：表示等待状态，如CONDITION（在条件队列中等待）等。</li></ul> <p>同步队列通过一个head节点和一个tail节点来维护。其中，head节点是一个哑节点，不表示任何实际的线程，而tail节点是队列中最后一个节点。</p> <p>当一个线程尝试获取锁时，它会创建一个新的Node节点，并将其插入到同步队列的尾部。同时，该线程会进入自旋，不断尝试获取锁。</p> <p>当一个线程成功获取到锁时，它会从同步队列中移除自己所对应的Node节点，并继续执行临界区代码。而其他的等待线程则会根据自己在队列中的位置，依次尝试获取锁。</p> <p>AQS的同步队列采用了CLH（Craig, Landin, and Hagersten）锁的一种变体，该锁是一种自旋锁。它通过线程之间的竞争，实现了高效的线程调度和资源分配。</p> <p>总结来说，AQS中的同步队列使用双向链表数据结构来管理等待获取资源的线程，通过节点的插入和移除操作来实现线程的排队和唤醒。这种设计使得AQS能够灵活地管理线程的等待状态，并提供高效的同步机制。</p> <h3 id="aqs为什么采用双向链表-而不是单向链表"><a href="#aqs为什么采用双向链表-而不是单向链表" class="header-anchor">#</a> AQS为什么采用双向链表，而不是单向链表</h3> <ul><li><strong>双向链表的优势</strong>：
<ul><li>提供了双向指针<strong>可以在任何一个节点方便向前或向后进行遍历</strong>，这种对于有反向遍历需求的场景来说非常有用</li> <li>可以在任意节点位置实现数据的插入和删除</li></ul></li> <li><strong>原因</strong>：
<ul><li>存储在双向链表的线程有可能这个线程出现异常，不再需要竞争锁，所以需要把这个异常节点从链表中去删除而删除操作需要找到这个节点的前驱节点，如果不采用双向链表，必须从头结点开始遍历，时间复杂度编O(N)</li> <li>新加入到链表的线程，在进入阻塞状态之前需要判断前驱节点的状态，采用双向链表，提升查找效率</li> <li>线程在加入链表之后，会通过自旋的方式，去尝试竞争锁来提升性能，为了保证竞争公平性，也需要获取前驱节点判断是否是当前节点，采用双向链表，提升查找效率</li></ul></li></ul> <h3 id="了解aqs-对资源的共享方式吗"><a href="#了解aqs-对资源的共享方式吗" class="header-anchor">#</a> 了解AQS 对资源的共享方式吗</h3> <ul><li><code>Exclusive</code>（独占）</li> <li><code>Share</code>（共享）</li></ul> <h3 id="aqs-组件了解吗"><a href="#aqs-组件了解吗" class="header-anchor">#</a> AQS 组件了解吗</h3> <p>是的，我了解AQS（AbstractQueuedSynchronizer）组件。</p> <p>AQS是Java中用于实现同步器的基础框架，它提供了一种用于构建锁和其他同步组件的强大工具。通过继承AQS并实现自定义的同步逻辑，开发人员可以轻松地创建各种类型的同步器，如独占锁、共享锁、信号量等。</p> <p>AQS的核心思想是使用一个整数状态来表示同步资源的可用性，并利用线程的CAS操作（Compare and Swap）来实现对状态的原子更新。AQS通过维护一个同步队列来管理等待获取资源的线程，并提供了相应的模板方法供具体的同步器来实现。</p> <p>AQS的主要特点包括：</p> <ul><li><p>支持独占模式和共享模式：AQS可以支持独占锁和共享锁两种模式。通过继承AQS并实现不同的获取和释放方法，可以实现不同类型的锁和同步组件。</p></li> <li><p>内置的FIFO同步队列：AQS内部使用一个双向链表作为同步队列，用于管理等待获取资源的线程。该队列采用FIFO（先进先出）的顺序，保证了线程的公平竞争。</p></li> <li><p>等待/通知机制：AQS通过等待队列和Condition对象提供了等待/通知机制，可以实现线程的阻塞和唤醒操作。</p></li> <li><p>可扩展性和灵活性：通过继承AQS并实现自定义的同步逻辑，开发人员可以根据需求轻松创建各种类型的同步器。</p></li> <li><p>高效的性能：AQS使用自旋和CAS操作来实现高效的线程调度和资源分配，避免了线程阻塞和切换的开销。</p></li></ul> <p>总而言之，AQS是Java中用于实现同步器的重要组件，它提供了一种灵活且高效的方式来构建各种类型的锁和同步组件。通过了解和使用AQS，开发人员可以更好地理解并设计多线程应用程序。</p> <h2 id="atomic-原子类"><a href="#atomic-原子类" class="header-anchor">#</a> Atomic 原子类</h2> <h3 id="介绍一下-atomic-原子类"><a href="#介绍一下-atomic-原子类" class="header-anchor">#</a> 介绍一下 Atomic 原子类</h3> <ul><li>简单点就是具有原子 / 原子操作特征的类。</li></ul> <h3 id="juc-包中的原子类是哪4类"><a href="#juc-包中的原子类是哪4类" class="header-anchor">#</a> JUC 包中的原子类是哪4类</h3> <ul><li>基本类型</li> <li>数组类型</li> <li>引用类型</li> <li>对象属性修改类型</li></ul> <h3 id="简单介绍一下-atomicinteger-类的原理"><a href="#简单介绍一下-atomicinteger-类的原理" class="header-anchor">#</a> 简单介绍一下 AtomicInteger 类的原理</h3> <ul><li>AtomicInteger 类主要利用 CAS和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</li></ul> <h3 id="补充"><a href="#补充" class="header-anchor">#</a> 补充</h3> <h3 id="为什么不建议使用executors创建线程"><a href="#为什么不建议使用executors创建线程" class="header-anchor">#</a> 为什么不建议使用Executors创建线程</h3> <ul><li>底层调用new ThreadPoolExecutro中的其中一个参数为<code>LinkedBlockingQueue</code></li> <li>创建的队列为<code>LinkedBlockingQueue</code>，是一个无界阻塞队列，如果使用该线程池执行任务，如果任务过多就会不断的添加到队列中，任务越多占用的内存就越多，最终可以耗尽内存，<strong>导致OOM</strong></li> <li>同时使用Executors创建线程池也不能自定义线程的名字，不利于排查问题</li></ul> <h3 id="线程池有几种状态"><a href="#线程池有几种状态" class="header-anchor">#</a> 线程池有几种状态</h3> <p><img src="https://cdn.nlark.com/yuque/0/2023/png/29617954/1678452467928-f95cba14-34b4-4ea1-8998-69a8d501e0c7.png#averageHue=%23f1f1f1&amp;clientId=uf6b2decf-7cc8-4&amp;from=paste&amp;height=498&amp;id=u1566ad8a&amp;name=image.png&amp;originHeight=623&amp;originWidth=1443&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=331166&amp;status=done&amp;style=none&amp;taskId=u6aae9bf6-3226-44fa-bb27-9b793dc6bf0&amp;title=&amp;width=1154.4" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2023/png/29617954/1678452401147-da4378cb-0940-453a-90b1-92d5f941fe14.png#averageHue=%23f3f3f3&amp;clientId=uf6b2decf-7cc8-4&amp;from=paste&amp;height=430&amp;id=ue9482d1d&amp;name=image.png&amp;originHeight=538&amp;originWidth=1443&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=265290&amp;status=done&amp;style=none&amp;taskId=ud3afbcb4-ce8f-47b6-9026-b05aca10f66&amp;title=&amp;width=1154.4" alt="image.png"></p> <h3 id="公平锁和非公平锁✔"><a href="#公平锁和非公平锁✔" class="header-anchor">#</a> 公平锁和非公平锁✔</h3> <ul><li>如果是公平锁，会先检查AQS队列中是否存在线程在排队，如果有线程在排队，则当前线程也进行排队</li> <li>如果是非公平锁，则不会去检查是否有线程在排队，而是直接竞争锁</li> <li><strong>总结</strong>：不管是公平锁还是非公平锁，一旦没有竞争到锁，都会进行排队，当锁释放时，都是唤醒锁排在最前面的线程，<strong>所有非公平锁只是体现在了线程加锁阶段，而没有体现在线程被唤醒阶段，二者都是可重入的</strong></li></ul> <h3 id="说说对线程安全的理解✔"><a href="#说说对线程安全的理解✔" class="header-anchor">#</a> 说说对线程安全的理解✔</h3> <ul><li>一段代码在多个线程同时执行的情况下，能否得到正确的结果</li> <li>多个线程同时执行这段代码时，不会产生混乱，依然能够得到正常的结果</li> <li>i++，i初始值0，两个线程同时执行，如果线程安全，一个1，一个2；如果两个线程都是1，说明线程不安全</li></ul> <p>1、原子性：一个线程执行是不可中断的，一旦出现中断，会出现前后不一致的问题</p> <p>2、可见性：多线程环境下，读和写发生在不同的线程里面，有可能会出现某个线程对共享变量的修改，对其他线程不是实时可见的</p> <p>3、有序性：程序编写的指令顺序和最终cpu运行的指令顺序可能出现不一致问题</p> <h3 id="并发、并行、串行之间的区别✔"><a href="#并发、并行、串行之间的区别✔" class="header-anchor">#</a> 并发、并行、串行之间的区别✔</h3> <ul><li><p>串行</p> <ul><li>一个任务执行完，才能执行下一个任务（排队）</li></ul></li> <li><p>并行</p> <ul><li><p>两个任务同时执行</p> <p>并行（parallel）是同一时间动手做（doing）多件事情的能力</p></li></ul></li> <li><p>并发</p> <ul><li><p>两个任务整体看上去是同时执行，在底层，两个任务被拆分成了很多份，然后一个一个执行，站在更高的角度看来两个任务是同时在执行的</p> <p>并发（concurrent）是同一时间应对（dealing	with）多件事情的能力</p></li></ul></li></ul> <blockquote><p>举例：</p> <ul><li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</li> <li>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生 竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）</li> <li>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</li></ul></blockquote> <h3 id="线程池为什么是先添加队列而不是先创建最大线程"><a href="#线程池为什么是先添加队列而不是先创建最大线程" class="header-anchor">#</a> 线程池为什么是先添加队列而不是先创建最大线程</h3> <p>在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。</p> <p>就好⽐⼀个企业⾥⾯有10个（core）正式⼯的名额，最多招10个正式⼯，要是任务超过正式⼯⼈数 （task &gt; core）的情况下，⼯⼚领导（线程池）不是⾸先扩招⼯⼈，还是这10⼈，但是任务可以稍微积压⼀下，即先放到队列去（代价低）。10个正式⼯慢慢⼲，迟早会⼲完的，要是任务还在继续增加，超 过正式⼯的加班忍耐极限了（队列满了），就的招外包帮忙了（注意是临时⼯）要是正式⼯加上外包还是不能完成任务，那新来的任务就会被领导拒绝了（线程池的拒绝策略）。</p> <h2 id="线程使用场景问题"><a href="#线程使用场景问题" class="header-anchor">#</a> 线程使用场景问题</h2> <h3 id="如何控制某一个方法允许并发访问线程的数量"><a href="#如何控制某一个方法允许并发访问线程的数量" class="header-anchor">#</a> 如何控制某一个方法允许并发访问线程的数量</h3> <p>在jdk中提供了一个Semaphore[seməfɔːr]类（信号量）</p> <p>它提供了两个方法，semaphore.acquire() 请求信号量，可以限制线程的个数，是一个正数，如果信号量是-1,就代表已经用完了信号量，其他线程需要阻塞了</p> <p>第二个方法是semaphore.release()，代表是释放一个信号量，此时信号量的个数+1</p> <h3 id="那该如何保证java程序在多线程的情况下执行安全呢"><a href="#那该如何保证java程序在多线程的情况下执行安全呢" class="header-anchor">#</a> 那该如何保证Java程序在多线程的情况下执行安全呢</h3> <p>刚才讲过了导致线程安全的原因，如果解决的话，jdk中也提供了很多的类帮助我们解决多线程安全的问题，比如：</p> <ul><li>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题</li> <li>synchronized、volatile、LOCK，可以解决可见性问题</li> <li>Happens-Before 规则可以解决有序性问题</li></ul> <h3 id="在项目中哪里用了多线程"><a href="#在项目中哪里用了多线程" class="header-anchor">#</a> 在项目中哪里用了多线程</h3> <p>参考场景一：</p> <p>es数据批量导入</p> <p>在我们项目上线之前，我们需要把数据量的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），如果分批执行的话，耗时也太久了。所以，当时我就想到可以使用线程池的方式导入，利用CountDownLatch+Future来控制，就能大大提升导入的时间。</p> <p>参考场景二：</p> <p>在我做那个xx电商网站的时候，里面有一个数据汇总的功能，在用户下单之后需要查询订单信息，也需要获得订单中的商品详细信息（可能是多个），还需要查看物流发货信息。因为它们三个对应的分别三个微服务，如果一个一个的操作的话，互相等待的时间比较长。所以，我当时就想到可以使用线程池，让多个线程同时处理，最终再汇总结果就可以了，当然里面需要用到Future来获取每个线程执行之后的结果才行</p> <p>参考场景三：</p> <p>我当时做了一个文章搜索的功能，用户输入关键字要搜索文章，同时需要保存用户的搜索记录（搜索历史），这块我设计的时候，为了不影响用户的正常搜索，我们采用的异步的方式进行保存的，为了提升性能，我们加入了线程池，也就说在调用异步方法的时候，直接从线程池中获取线程使用</p> <h2 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h2> <h3 id="编写一个基于线程安全的懒加载单例模式"><a href="#编写一个基于线程安全的懒加载单例模式" class="header-anchor">#</a> 编写一个基于线程安全的懒加载单例模式</h3> <p>关键点：</p> <ol><li>多线程访问</li> <li>防止直接new对象</li> <li>使用锁</li> <li>内部类加载实现、cas实现等</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test03</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">Test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>


    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Test03</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span>  <span class="token keyword">static</span>  <span class="token class-name">Test03</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token comment">// 有可能在多线程访问的时候，重复new 了对象</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

            <span class="token comment">// 可能会有多个线程 进入抢锁等待状态</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Test03</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="伪共享的概念以及如何避免✔"><a href="#伪共享的概念以及如何避免✔" class="header-anchor">#</a> 伪共享的概念以及如何避免✔</h3> <p>为了提高CPU的利用率，平衡CPU和内存之间的一个速度差异，在CPU里面设计了三级缓存，CPU在向内存发起IO操作时，一次性会读取64个字节数据作为一个缓存行，java中应该Long类型是8个字节，意味着一个缓存行可以存储8个Long类型的 变量，缓存行的设计，对于CPU来说，可以有效的去减少和内存的交互次数，从而去避免、CPU和IO的一个等待，从而去提升CPU的一个利用率，恰好是因为这样子缓存行的设计啊，导致了如果多个线程修改同一缓存行里面的多个独立变量的时候，基于缓存一致性协议呢，就会无意中影响了彼此的性能，这就是为共享的问题。</p> <ul><li>使用对齐填充</li> <li>使用@Contented注解</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/interview-docs/my-docs/Interview/07-Java集合.html" class="prev">
        Java集合
      </a></span> <span class="next"><a href="/interview-docs/my-docs/Interview/09-JVM.html">
        JVM
      </a>
      →
    </span></p></div> </main></div> <div class="footer" data-v-34d4abe6><div id="footer-info" data-v-34d4abe6><div class="footer-left" data-v-34d4abe6>
      © 2023-2024
      <span data-v-34d4abe6>lxy25122</span></div> <div class="footer-right" data-v-34d4abe6>Theme:<a href="https://github.com/JoeyBling/vuepress-theme-yilia-plus" target="_blank">vuepress-theme-yilia-plus</a> by Litten</div></div> <!----></div></main><div class="global-ui"><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:65px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div></div></div>
    <script src="/interview-docs/assets/js/app.67f6cb80.js" defer></script><script src="/interview-docs/assets/js/2.eee71d3c.js" defer></script><script src="/interview-docs/assets/js/1.a356cc6d.js" defer></script><script src="/interview-docs/assets/js/30.18027547.js" defer></script>
  </body>
</html>
