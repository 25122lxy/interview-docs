# 数据结构与算法

## 数据结构

> 底层基础决定上层建筑，数据结构与算法就是基石之一。

> CPU，内存，磁盘这是计算机三个重要的部件。
>
> `CPU`负责运算(计算)。
>
> `内存`和`磁盘`属于数据媒介，负责`存储`并提供数据。
>
> 数据存储，需要有载体，这个载体，我们称之为`数据结构`

**JVM是运行在内存中，所以这里的存储媒介我们讲的是内存**

指定jdk版本 1.8

```xml
<properties>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
    <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
    <encoding>UTF-8</encoding>
</properties>
```

### 1.数组

> `数组`是一组`连续内存空间`存储的具有`相同类型`的数据，是一种`线性结构`。

![1.数组](https://gitee.com/tjlxy/img/raw/master/1.%E6%95%B0%E7%BB%84.jpg)

`优势是什么？`

1. `类型固定`: 意味着长度固定
2. `连续内存空间`
3. 因为上述两点特性，基于初始地址，可以计算数组任意位置的内存地址，所谓的`查询快`
4. `随机存取`**【读取】**：通过下标直接访问，即访问第N个元素，不需要访问前(N-1)个数据
5. `顺序存储`：在内存中按顺序存放

`劣势是什么?`

1. 数据初始化需要连续的内存空间，数据在内存当中是随机存放的，不一定有指定长度的连续空间
2. 当插入数据的时候，为了保持连续性，需要做数据迁移（想想如果，添加一个数据，需要向后移动一位，但是如果这一位被其他数据占用了，那么整个数组都需要进行迁移，找到能存放下的内存空间）
3. 同样的道理，删除的时候，也需要做数据迁移

**注意事项：尽量在数组初始化的时候，就确定其大小，数组适合读多的场景**

**代码实现**

```java
import java.util.Arrays;
import java.util.Iterator;

/**
 * @user 25122
 * @date 2023/4/20
 * @time 9:35
 * ArrayList数组实现
 */
public class ArrayListTest<E> implements Iterable<E>{

    //声明数组
    private Object[] elementData;


    /**
     * 初始化 elementData 数组
     * @param capacity 数组容量
     */
    public ArrayListTest(int capacity){
        //进行数组的初始化操作，设定容量
        this.elementData = new Object[capacity];

    }

    /***
     * 注意:Test1[5] = {1,2,3,4,5}
     *    对应索引: 0 1 2 3 4
     *    容量: 5
     * 向数组中添加元素，往尾部追加
     * @param element
     * @return
     */
    public boolean add(E element){
        //获取 elementData 原数组容量
        int size = this.elementData.length;
        //设置 newCapacity 新数组容量（原数组容量+1）
        int newCapacity = size + 1;
        //重新申请容量，新增数据的时候，需要扩容，整体数据就需要进行迁移
        //性能消耗，实际上，扩容的时候，两倍扩容
        elementData = Arrays.copyOf(this.elementData,newCapacity);
        //添加元素->对 elementData 数组最后一位赋值
        elementData[size] = element;
        return true;
    }

    /**
     * set设定值，插入元素
     * @param index 索引值
     * @param element 元素
     * @return
     */
    public E set(int index,E element){
        //获取之前索引位置的值
        E oldValue = (E)this.elementData[index];
        this.elementData[index] = element;
        return oldValue;
    }

    /**
     * get方法，根据索引位置取值
     * @param index 索引值
     * @return
     */
    public E get(int index){
        return (E) this.elementData[index];
    }

    /***
     * 实现Iterable接口，重写迭代器
     * @return
     */
    @Override
    public Iterator<E> iterator() {
        return new IteratorTest();
    }

    /**
     * 迭代器
     */
    class IteratorTest implements Iterator<E>{

        int index = 0;

        /**
         * 是否有下一个值
         *  注意：索引长度应该始终比容量小1
         * @return
         */
        @Override
        public boolean hasNext() {
            return index != elementData.length;
        }

        /**
         * 获取下一个值
         * @return
         */
        @Override
        public E next() {
            return (E)elementData[index++];
        }
    }

    public static void main(String[] args) {
        ArrayListTest<String> arrayListTest = new ArrayListTest<String>(5);
        arrayListTest.add("5");
        arrayListTest.add("6");
        arrayListTest.set(0,"1");
        int i = 0;
        //Lambda表达式
        arrayListTest.forEach(s -> {
            System.out.println(s);
        });
        for (String s : arrayListTest) {
            System.out.println("index-"+ i++ +": "+s);

        }

    }

}

```

### 2.链表

> 链表一种`非连续`、`非顺序`的存储结构，由一系列节点组成，节点间通过`指针完成了串联`，每个节点包含`数据`和`下一个节点指针`两部分。

![2.链表](https://gitee.com/tjlxy/img/raw/master/2.%E9%93%BE%E8%A1%A8.jpg)

根据指针的方向可以分为：

- 单向链表
- 循环链表
- 双向链表
- 双向循环链表

`优势是什么？`

1. 不需要连续空间，较灵活
2. `随机存储`：非顺序存储
3. 插入，删除时，只需要更改指针指向即可，开销小

`劣势是什么？`

1. 每个节点除了存储数据，还存储指针，占用额外的空间
2. `顺序存取`【读取】：存取第N个数据时，必须先访问前(N-1)个数据，效率低

**链表适合写多的场景**

**代码实现**

```java
import java.util.Iterator;

/**
 * @user 25122
 * @date 2023/4/21
 * @time 9:29
 * LinkedList链表 实现
 */
public class LinkedListTest<E> implements Iterable<E> {

    //定义链表长度
    private int size;

    //头节点
    private Node<E> first;

    //尾节点
    private Node<E> last;

    /**
     * 定义节点
     */
    private static class Node<E>{
        E item;//当前元素
        Node<E> prev;//上一个
        Node<E> next;//下一个

        /***
         * 构造方法
         * @param prev 上一个节点
         * @param item 当前节点
         * @param next 下一个节点
         */
        public Node(Node<E> prev,E item,Node<E> next){
            this.item = item;
            this.prev = prev;
            this.next = next;
        }


    }

    /**
     * 向链表中添加元素，需指向上一个节点
     * @param element
     * @return
     */
    public boolean addLast(E element){
        //上一个节点
        final Node<E> l = last;
        //添加元素
        Node<E> newNode = new Node<>(l,element,null);
        last = newNode;
        //判断是否有上一个节点
        if (l == null) {
            //没有上一个节点，当前节点就是头结点
            this.first = newNode;
        }else {
            //有上一个节点，则上个节点的下一个就是当前节点
            l.next = newNode;
        }
        //链表长度加一
        size++;
        return true;
    }

    /**
     * 找索引位置的节点 (查询性能低)
     * @param index 索引值
     * @return
     */
    private Node<E> node(int index){
        //判断索引位置 是否小于 (size 往右移一位的位置，相当于除，变为原来的一半)
        if (index < (size >> 1)){// 结果为true 则index索引位置在链表前半部分
            //将头结点的位置赋予当前索引值
            Node<E>  x = this.first;
            //遍历，查找当前索引位置的元素值
            for (int i = 0; i < index; i++) {
                //从头节点开始遍历，一直去头结点的下一个，查找当前索引位置的值
                x = this.first.next;
            }
            //返回当前节点
            return x;
        }else {// 结果为false 则index索引位置在链表后半部分
            //将尾结点的位置赋予当前索引值
            Node<E> x = this.last;
            for (int i = size - 1; i > index; i--) {
                //从尾节点开始遍历，一直去找上一个节点，查找当前索引位置的值
                x = this.last.prev;
            }
            //返回当前节点
            return x;
        }
    }

    /**
     * 设定值，插入元素
     * @param index
     * @param element
     * @return
     */
    public E set(int index,E element){
        //找到当前索引位置的节点
        Node<E> x = node(index);
        //则当前索引位置的节点的值为 旧元素
        E oldValue = x.item;
        //将当前素养位置的节点值 替换位 需要插入的元素(新元素)
        x.item = element;
        //返回旧元素
        return oldValue;
    }

    /**
     * 获取当前索引位置节点的值
     * @param index
     * @return
     */
    public E get (int index){
        return node(index).item;
    }

    /***
     * 实现Iterable接口，重写迭代器
     * @return
     */
    @Override
    public Iterator<E> iterator() {
        return new IteratorTest();
    }

    /**
     * 迭代器
     */
    class IteratorTest implements Iterator<E>{
        int index = 0;
        /**
         * 是否有下一个值
         * @return
         */
        @Override
        public boolean hasNext() {
            return index!= size;
        }
        /**
         * 获取下一个值
         * @return
         */
        @Override
        public E next() {
            return get(index++);
        }

    }

    public static void main(String[] args) {
        LinkedListTest<String> linkedListTest = new LinkedListTest<>();
        linkedListTest.addLast("1");
        linkedListTest.addLast("2");
        linkedListTest.addLast("3");
        linkedListTest.set(1,"one");
        int index = 0;//声明索引位置
        linkedListTest.forEach(s -> {
            System.out.println(s);
        });
        for (String s : linkedListTest) {
            System.out.println("index-" + index++ + ": " + s);
        }
    }
}

```



### 3.栈

> 又名`堆栈`，限定仅在`表尾进行插入和删除`操作的`线性表`（把所有数据用一根线儿串起来，再存储到物理空间中）。
>
> 上面成为`栈顶`，下面称为`栈底`。
>
> 向栈插入新元素称为`入栈`，新元素放到栈顶；从一个栈删除元素又称作`出栈`，它是把栈顶元素删除掉，使其下面相邻的元素成为新的栈顶元素。

![3.栈](https://gitee.com/tjlxy/img/raw/master/3.%E6%A0%88.jpg)

根据底层结构不同，可以分为：

1. `数组实现的顺序栈`
2. `链表实现的链式栈`

`优势是什么？`

1. 先进后出，后进先出
2. 只能操作栈顶元素，可控性好，适合特殊场景

`劣势是什么?`

1. 只能操作栈顶元素

`应用场景`

1. JVM的本地方法栈，函数调用
2. 浏览器的前进、后退

**代码实现**

- 数组实现的顺序栈：

```java
import java.util.Arrays;

/**
 * @user 25122
 * @date 2023/4/23
 * @time 9:35
 * 栈： 后进先出
 * 数组实现的顺序栈
 */
public class ArrayStack<E> {

    //声明数组
    private Object[] elementData;

    //声明栈顶索引
    private int topIndex;

    /**
     * 构造函数 初始化
     * @param capacity 数组容量
     */
    public ArrayStack(int capacity){
        this.elementData = new Object[capacity];
    }

    /**
     * 入栈
     * @param element 入栈元素
     * @return
     */
    public boolean push(E element){
        //判断 栈顶索引是否超过栈长度  判断栈是否已满
        if (this.topIndex >= this.elementData.length){
            //true 栈满 进行扩容  左移一位，扩容为原来的两倍
            Arrays.copyOf(this.elementData,this.elementData.length << 1);
        }
        //向栈中添加
        this.elementData[this.topIndex++] = element;
        return true;
    }

    /**
     * 出栈 出栈同时删除栈顶元素
     * @return
     */
    public E pop(){
        //判断栈中是否有元素
        if (this.topIndex <= 0){
            throw new RuntimeException("栈为空");
        }
        return (E)this.elementData[--topIndex];
    }

    /**
     * 出栈 返回栈顶元素，不删除
     * @return
     */
    public E peek(){
        if (this.topIndex <= 0){
            throw new RuntimeException("栈为空");
        }
        return (E)this.elementData[topIndex-1];
    }

    public static void main(String[] args) {
        ArrayStack<Object> arrayStack = new ArrayStack<>(10);
        System.out.println("入栈。。。");
        arrayStack.push("1");
        arrayStack.push("2");
        arrayStack.push("3");
//        System.out.println("pop出栈。。。");
//        System.out.println(arrayStack.pop());
//        System.out.println(arrayStack.pop());
        System.out.println("peek出栈。。。");
        System.out.println(arrayStack.peek());
        System.out.println(arrayStack.peek());
//        System.out.println("pop出栈。。。");
//        System.out.println(arrayStack.pop());
//        System.out.println("pop出栈。。。");
//        System.out.println(arrayStack.pop());
    }

}



```

- 链表实现的链式栈:

```java
package com.tjetc.structs.stack;

/**
 * @user 25122
 * @date 2023/4/23
 * @time 10:02
 * 栈 后进先出
 * 链表实现的链式栈
 */
public class LinkedStack<E> {

    /**
     * 定义节点
     *
     * @param <E>
     */
    private static class Node<E>{
        E item; //当前元素
        Node<E> next; //下一个元素
        public Node(E item,Node<E> next){
            this.item = item;
            this.next = next;
        }
    }


    //定义栈顶
    private Node<E> header;
    //元素个数
    private int elementCount;

    /**
     * 入栈
     * @param element 入栈元素
     * @return
     */
    public boolean push(E element){
        //新入栈的元素 变为 栈顶 下一个元素变为 之前的header栈顶
        this.header = new Node<>(element,header);
        //元素个数+1
        this.elementCount++;
        return true;
    }

    /**
     * 出栈 并删除
     * @return
     */
    public E pop(){
        //判断栈顶元素是否为空
        if (this.header == null){
            throw new RuntimeException("栈为空");
        }
        //声明出栈元素 栈顶元素
        E item = this.header.item;
        //下一个元素 变为 栈顶元素
        this.header = this.header.next;
        //元素个数
        this.elementCount--;
        return item;
    }

    /***
     * 出栈
     * @return
     */
    public E peek(){
        if (this.header == null){
            throw  new RuntimeException("栈为空");
        }
        return this.header.item;
    }

    public static void main(String[] args) {
        LinkedStack<Object> linkedStack = new LinkedStack<>();
        System.out.println("入栈。。。");
        linkedStack.push("1");
        linkedStack.push("2");
        linkedStack.push("3");
//        System.out.println("pop出栈。。。");
//        System.out.println(linkedStack.pop());
//        System.out.println(linkedStack.pop());
        System.out.println("peek出栈。。。");
        System.out.println(linkedStack.peek());
        System.out.println(linkedStack.peek());
//        System.out.println("pop出栈。。。");
//        System.out.println(linkedStack.pop());
//        System.out.println("pop出栈。。。");
//        System.out.println(linkedStack.pop());
    }

}

```

### 4.队列

> `队列`是一种特殊的`线性表`，只允许在表的前端进行读取删除操作，而在表的后端进行插入操作。
>
> 和栈一样，队列是一种操作受限制的线性表。
>
> `插入`的数据放在`队尾`，`读取数据`的端称为`队头`。
>
> 队列中没有元素时，称为空队列。

![4.队列](https://gitee.com/tjlxy/img/raw/master/4.%E9%98%9F%E5%88%97.jpg)

根据底层结构不同，可以分为：

1. `数组实现的顺序队列`
2. `链表实现的链式队列`

根据支持的高级特性，还有以下队列：

1. 循环队列
2. 双端队列
3. 阻塞队列
4. 非阻塞队列

`优势是什么？`

1. 先进先出
2. 规则固定，可控性好，适合特殊场景

`劣势是什么?`

1. 不能直接操作队列中间的元素

`场景举例`

1. 限流
2. 线程池，来不及处理的任务会放入任务队列 
3. Kafka，RocketMQ等代表的消息中间件

**代码实现**

- 数组实现的顺序队列

```java
import java.util.Arrays;

/**
 * @user 25122
 * @date 2023/4/24
 * @time 9:26、
 * 数组实现的顺序队列
 */
public class ArrayQueue<E> {
    //声明队头
    private int head;
    //声明队尾
    private int tail;
    //声明数组
    private Object[] elementData;

    /***
     * 构造函数初始化
     * @param capacity
     */
    public ArrayQueue (int capacity){
        this.elementData = new Object[capacity];
    }

    /**
     * 入队
     *
     *          队头                          队尾
     *          (1)  (2)  (3)  (4)  (5)  (6)  (7)
     *               队头                           队尾
     * (1)号出队      (2)  (3)  (4)  (5)  (6)  (7)  (8)   (8)号入队
     *
     * @param element 入队元素
     * @return
     */
    public boolean enQueue(E element){
        //判断 队尾索引是否超过队列长度  判断队列是否已满
        if (this.tail >= this.elementData.length){
            //true 队列已满 进行扩容  左移一位，扩容为原来的两倍
            this.elementData = Arrays.copyOf(this.elementData,this.elementData.length << 1);
            //判断队头 是否移动
            if (this.head != 0){
                // 队头移动 进行数据迁移
                if (this.tail - this.head >= 0){
                    //复制源elementData，从head开始复制，复制到elementData队列里，复制到从0开始，复制长度是tail- head
                    System.arraycopy(this.elementData,this.head,this.elementData,0,this.tail - this.head);
                }
                //获取队尾
                this.tail = this.tail - this.head;
                //获取队头
                this.head = 0;
            }
        }
        //尾部入队
        this.elementData[tail++] = element;
        return true;
    }

    /***
     * 出队
     * @return
     */
    public E deQueue(){
        //判断是否为空
        if (this.tail == this.head){
            throw new RuntimeException("队列为空");
        }
        return (E)this.elementData[this.head++];
    }

    public static void main(String[] args) {
        ArrayQueue<String> arrayQueue = new ArrayQueue<>(3);
        System.out.println("入队。。。");
        arrayQueue.enQueue("1");
        arrayQueue.enQueue("2");
        arrayQueue.enQueue("3");
        System.out.println("出队。。。");
        System.out.println(arrayQueue.deQueue());
        System.out.println("入队。。。");
        arrayQueue.enQueue("4");
        System.out.println("出队。。。");
        System.out.println(arrayQueue.deQueue());
        System.out.println(arrayQueue.deQueue());
        System.out.println(arrayQueue.deQueue());

    }

}

```

- 链表实现的链式队列

```java

/**
 * @user 25122
 * @date 2023/4/24
 * @time 10:07
 * 链表实现的链式队列
 */
public class LinkedQueue<E> {

    /**
     * 定义节点
     *
     * @param <E>
     */
    private static class Node<E>{
        E item; //当前元素
        LinkedQueue.Node<E> next; //下一个元素
        public Node(E item, LinkedQueue.Node<E> next){
            this.item = item;
            this.next = next;
        }
    }
    //声明队头
    private Node<E> head;
    //声明队尾
    private Node<E> tail;

    /**
     * 入队操作
     * @param element
     * @return
     */
    public boolean enQueue(E element){
        //队尾入队 下一个元素是null
        Node<E> newNode = new Node<>(element,null);
        //判断是否为第一次
        if (this.tail == null){
            this.tail = newNode;
            this.head = this.tail;
            return true;
        }
        //当前节点为 上一个队列队尾的下一个节点
        this.tail.next = newNode;
        //当前节点变为当前队列的队尾
        this.tail = newNode;
        return true;

    }

    /***
     * 出队
     * @return
     */
    public E deQueue(){
        if (this.head == null){
            throw new RuntimeException("队列为空");
        }
        E item= this.head.item;
        //指针后移
        this.head = this.head.next;
        return item;
    }

    public static void main(String[] args) {
        LinkedQueue<String> linkedQueue = new LinkedQueue<>();
        System.out.println("入队。。。");
        linkedQueue.enQueue("1");
        linkedQueue.enQueue("2");
        linkedQueue.enQueue("3");
        System.out.println("出队。。。");
        System.out.println(linkedQueue.deQueue());
        System.out.println("入队。。。");
        linkedQueue.enQueue("4");
        System.out.println("出队。。。");
        System.out.println(linkedQueue.deQueue());
        System.out.println(linkedQueue.deQueue());
        System.out.println(linkedQueue.deQueue());

    }

}

```

### 5.哈希表 

> 哈希表（Hash table）也叫散列表。
>
> 根据`键（Key）`而`直接访问`在内存储存位置的数据结构。
>
> 它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
>
> 这个映射函数称为`散列函数`，存放记录的数组称做`散列表`。
>
> 常见的`散列(哈希)函数`有`MD5`、`SHA`、`CRC`等



![5.哈希表](https://gitee.com/tjlxy/img/raw/master/5.%E5%93%88%E5%B8%8C%E8%A1%A8.jpg)

`优势是什么?`

1. 将数据有效的做了切分，分而治之
2. 通过Key可以直接获取到要查找的数据，查询效率高

`劣势是什么?`

1. 可能存在hash冲突

> 如果有HASH冲突，那么在冲突的位置，将数据构建为链表结构，极端情况下，HASH表可能会退化为链表，所有元素都被存储在同一个节点的链表中。O(n)
>
> **`装载因子=哈希表中的元素个数 / 哈希表长度`，如果装载因子过大，说明链表的长度越长，性能越低，哈希表需要进行扩容，将数据迁移到新的哈希表中。**

`场景举例：`

1. Redis
2. HashMap

**代码实现**

```java
/**
 * @user 25122
 * @date 2023/4/25
 * @time 10:31
 * 哈希表的实现
 */
public class HashTable<K,V> {

    //散列表 数组结构（每一个元素上 是一个链表结构） 定义数组
    private Node<K,V>[] table;

    private static class Node<K,V>{
        //hash函数计算的结果
        final int hash;
        final K key;
        V value;
        //下一个元素
        Node<K,V> next;

        public Node(int hash,K key,V value,Node<K,V> next){
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    /**
     * 构造函数 进行 初始化 数组
     * @param capacity
     */
    public HashTable(int capacity){
        this.table = (Node<K,V>[])new Node[capacity];

    }

    /**
     * 添加元素
     * @param key
     * @param value
     */
    public void put(K key,V value){
        //计算哈希值
        int hash = hash(key);
        //计算数组中的索引值
        int i = (this.table.length - 1) & hash;
        //声明节点
        Node<K,V> node = new Node<>(hash,key,value,null);
        //获取对应数组值
        Node<K,V> kvNode = table[i];
        if (kvNode == null) {
            //这个数组位置 没有数据 是第一个
            table[i] = node;
            return;
        }
        //数组位置有值
        //需要判断一下key是否相等，key相等的情况下 进行替换
        if (kvNode.key.equals(key)) {
            //key相等，直接赋值
            kvNode.value = value;
        }else {
            //key不相等，挂在下一个节点
            kvNode.next = node;
        }

    }

    /**
     * 获取元素
     * @param key
     * @return
     */
    public V get(K key){
        //计算哈希值
        int hash = hash(key);
        //计算数组中的索引值
        int i = (this.table.length - 1) & hash;
        Node<K,V> node = table[i];
        if (node == null){
            return null;
        }
        Node<K,V> newNode = node;
        //正常 做一个循环，查找key是否匹配，直到next为null
        while (node.next != null){
            if (newNode.key.equals(key)){
                break;
            }
            newNode = newNode.next;
        }
        return newNode.value;
    }

    /**
     * 计算哈希值
     * @param key
     * @return
     */
    static final int hash(Object key){
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }


    public static void main(String[] args) {
        HashTable<String, String> hashTable = new HashTable<>(10);
        hashTable.put("key1","hadoop");
        hashTable.put("key2","hive");
        hashTable.put("key1","spark");
        hashTable.put("key2","flink");
        System.out.println(hashTable.get("key1"));
        System.out.println(hashTable.get("key2"));
        System.out.println(hashTable.get("key2"));

    }

}

```

### 6.图

> 图(Graph)是由顶点的有穷非空集合和顶点之间的集合组成，通常表示为：`G（V, E）`，其中 `G 表示一个图`，`V 是图 G 中顶点的集合`，`E 是图 G 中边的集合`。

![6.图](https://gitee.com/tjlxy/img/raw/master/6.%E5%9B%BE.jpg)

根据图是否有方向、权重等可以分为:

1. 有向图
2. 无向图
3. 带权图

**图主要有以下两种存储方式：**

1. 邻接矩阵。比较浪费空间，但是优点是查询效率高
2. 邻接表。每个顶点对应一个链表，比较节省存储空间，但是查询效率会低些。当然为了提高查询效率，可以将里面的链表替换成红黑树、跳表、或者平衡二叉树。

`优势是什么？`

1. 任意点都可以建立关系，存储的数据量大（信息完备）
2. 可以描述两个顶点之间的关系，称之为`边`

`劣势是什么？`

1. 存储数据量大
2. 图用多维数组表示，将图运算转换为矩阵运算，较为复杂
3. 图稀疏的话，采用邻接表，节省空间

`场景举例：`

1. 地图如何计算出最优出行路线
2. 深度优先搜索
3. 广度优先搜索
4. 最小生成树

**相关术语：**

1. **出度**：由某个顶点指出的边的个数；
2. **入度**：指向某个顶点的边的个数；
3. **有向路径**：由一系列顶点组成，其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点
4. **有向环**：至少含有一条边，且起点和终点相同的有向路径

**代码实现**

**两个顶点v和w可能存在的4种关系：**

1. 没有边相连
2. 存在从v到w的边v->w
3. 存在从w到v的边w->v
4. 既存在v->w，也存在w->v，即双向连接

```java
/**
 * @user 25122
 * @date 2023/4/26
 * @time 14:23
 * 图的实现
 */
public class GraphTest {

    //顶点集合
    private char[] vertex;

    //邻接矩阵
    private int[][] matrix;

    /**
     *
     * @param vexs 顶点合 {'A','B','C','D'}
     * @param edges 边集合{{'A','C'},{'B','A'},{'B','D'},{'C','B'},{'C','D'},{'D','B'}}
     */
    public GraphTest(char[] vexs,char[][] edges){
        //顶点长度
        int vLen = vexs.length;
        //边长度
        int eLen = edges.length;

        //初始化顶点集合
        this.vertex = new char[vLen];
        //复制数组 复制vexs 到 vertex， 从 0 位置开始 到 0 位置， 复制长度 vLen
        System.arraycopy(vexs,0,vertex,0,vLen);
        //边 4X4
        this.matrix = new int[vLen][vLen];
        for (int i = 0; i < eLen; i++) {
			//拿到集合中的 第一个集合的两个元素 {'A','C'}
            int p1 = getPosition(edges[i][0]);//A 0
            int p2 = getPosition(edges[i][1]);//C 2
            matrix[p1][p2] = 1; // (0,2)

        }

    }

    private int getPosition(char c){
		//在顶点集合中找元素位置
        for (int i = 0; i < this.vertex.length; i++) {
            if (vertex[i] == c){
                return i;
            }
        }

        return -1;
    }


    /**
     * 打印 矩阵
	 */
    public void print(){
        for (int i = 0; i < vertex.length; i++) {
            for (int j = 0; j < vertex.length; j++){
                System.out.printf("%d ",matrix[i][j]);
            }
            System.out.println();
        }
    }


    public static void main(String[] args) {
		//定义数组		0	1	2	3
        char[] vexs = {'A','B','C','D'};
		//定义矩阵			0 ,	2	  1 , 0		1 , 3	  2 , 1		2 , 3	  3 , 1
        char[][] edges = {{'A','C'},{'B','A'},{'B','D'},{'C','B'},{'C','D'},{'D','B'}};
        //生成图
		GraphTest graphTest = new GraphTest(vexs,edges);
		//打印矩阵
        graphTest.print();
    }

}

```

### 7.树 

> 树是N (N >= 0 )个节点的有限集合,N = 0 时,称为空树。
>
> 树上的每一个元素称为节点，节点与节点之间有一定的关系，上下称为`父子节点`，左右称为`兄弟节点`。

![7.树](https://gitee.com/tjlxy/img/raw/master/7.%E6%A0%91.jpg)

按照树的表现结构，可以具体分为以下几种类型：

1. 二叉树
2. 平衡二叉树
3. 满二叉树
4. 完全二叉树
5. 递归树
6. 红黑树
7. B- 树
8. B+ 树

**每个节点包含：数据值，左子节点指针，右子节点指针**

`优势是什么？`

1. 树形结构，支持数据的快速插入、查找、删除
2. 支持多种遍历方式：前序遍历（根左右）、中序遍历（左根右）、后序遍历（左右根）
3. 结构特殊，适合用递归来实现

`劣势是什么?`

1. 删除节点麻烦
2. 删除节点-物理删除，需要重新构造树结构
3. 删除节点-逻辑删除，产生内存碎片

**代码实现**

```java
/**
 * @user 25122
 * @date 2023/4/27
 * @time 9:38
 * 树的实现
 */
public class Tree<E> {

    E item;
    //左指针
    Tree<E> left;
    //右指针
    Tree<E> right;

    public Tree(E item){
        this.item = item;
    }

    /**
     * 构建左子树
     * @param item
     * @return
     */
    public Tree<E> buildLeft(E item){
        this.left = new Tree<>(item);
        return this.left;
    }

    /**
     * 构建右子树
     * @param item
     * @return
     */
    public Tree<E> buildRight(E item){
        this.right = new Tree<>(item);
        return this.right;
    }

    /**
     * 打印前序遍历
     *  根左右
     *
     */
    public void printPreOrder(){
        //根
        System.out.print(this.item + " > ");
        //左
        print(this.left);
        //右
        print(this.right);
    }
    /**
     * 打印
     */
    public void print(Tree<E> node){
        if (node == null) return;
        System.out.print(node.item + " > ");
        print(node.left);
        print(node.right);
    }

    public static void main(String[] args) {
        //声明根节点
        Tree<Integer> root = new Tree<>(10);
        //声明根的左节点
        Tree<Integer> left = root.buildLeft(6);
        Tree<Integer> ll = left.buildLeft(4);
        ll.buildLeft(2);
        left.buildRight(8);
        //声明根的右节点
        Tree<Integer> right = root.buildRight(18);
        right.buildLeft(13);
        right.buildRight(20);

        root.printPreOrder();
    }
}
```

### 8.堆

> 一种特殊的二叉树。需要满足两个条件：
>
> 1. 是一棵完全二叉树 
> 2. 堆中每个节点的值必须>=或<=其左右子节点的值。

![8.堆](https://gitee.com/tjlxy/img/raw/master/8.%E5%A0%86.jpg)

根据每个节点的值是>= 还是 <= 子树中每个节点的值，分为

1. 大顶堆
2. 小顶堆

**节点的值只能比左右子节点，大或者小 只能选择一个**

`优势是什么？`

1. 时间复杂度较低
2. 获取堆顶元素的时间复杂度为 O(1)
3. 假设完全二叉树包含n个节点，插入元素、删除元素，时间复杂度为 O(logn)

`劣势是什么？`

1. 特殊的二叉树，只能用于特定场景

`场景举例：`

1. 堆排序
2. 优先级队列
3. 求 TOP K
4. 求中位数

**代码实现**

```java
/**
 * @user 25122
 * @date 2023/4/28
 * @time 9:40
 * 堆的实现
 */
public class HeapNode {

    //堆中元素的大小 数量
    private int size;
    //堆数组
    private int[] heap;

    /**
     * 构造方法 初始化
     * @param capacity
     */
    public HeapNode(int capacity){
        this.heap = new int[capacity];
    }

    /**
     * 往堆中放入数据，构建小顶堆
     * @param n
     */
    public void offer(int n){
        //声明堆大小
        int i = size;
        while (i > 0) {
            //得到父节点位置
            int parent = (i - 1) >>> 1;//除二
            //得到父节点值
            int v = heap[parent];
            //判断插入数据 和 当前父节点的大小关系
            if (n >= v){
                break;
            }
            //插入数据 小于 当前父节点 换位置
            heap[i] = v;
            i = parent;

        }
        //堆中没有元素，直接赋值
        heap[i] = n;
        //数量+1
        size++;

    }

    /**
     * 取出堆顶部的元素，并且进行删除
     * 删除之后，破坏了结构，重新构建 小顶堆
     * @return
     */
    public int pop(){
        int top = heap[0];
        //声明新的堆，长度-1
        int[] newHeap = new int[size - 1];
        //整体偏移
        System.arraycopy(heap,1,newHeap,0,size - 1);
        heap = new int[heap.length];
        //初始化之后，元素数量归零
        size = 0;
        for (int i : newHeap){
            offer(i);
        }
        return top;
    }

    /**
     * 取出堆顶部的元素，不删除
     * @return
     */
    public int peek(){
        return heap[0];
    }

    public static void main(String[] args) {
        HeapNode heapNode = new HeapNode(6);
        heapNode.offer(4);
        heapNode.offer(2);
        heapNode.offer(5);
        heapNode.offer(7);
        heapNode.offer(3);
        System.out.println(heapNode.peek());
        System.out.println(heapNode.pop());
        System.out.println(heapNode.peek());
        heapNode.offer(1);
        System.out.println(heapNode.peek());
    }


}

```


#### Top K求解

**示例：从10亿个数据中找到最大的前10个？**

- 假设10亿个数据存在数组中
- 取前10个数据，构建一个小顶堆，那么根节点是最小的
- 然后，从数组中依次取出一个数据与堆顶比较，如果大于，替换掉堆顶元素，堆内部调整；如果小于等于堆顶，不做处理
- 同样逻辑，依次循环处理数组中每一个元素。
- 当10亿个数据处理完后，堆中的数据就是Top 10

```java
import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;

/**
 * @user 25122
 * @date 2023/5/4
 * @time 9:53
 * Top k 求解
 */
public class HeapTopK {

    public static void main(String[] args) {
        int[] nums = new int[]{1,5,4,2,3,6};
        System.out.println(topKMax(nums, 5));	//输出：[2, 3, 4, 5, 6]

    }

    /***
     * 获取最大的几个数 【使用小顶堆】
     * @param nums
     * @param k 最大个数
     * @return
     */
    private static List<Integer> topKMax(int[] nums, int k) {
        //寻找前k个最小数，因此将小顶堆大小定义为k
//        HeapNode heapNode = new HeapNode(k);
        PriorityQueue<Integer> heapNode = new PriorityQueue(k);//默认小顶堆
        for (int i = 0; i < nums.length; i++) {
            if (i < k){
                //放入元素
                heapNode.offer(nums[i]);//前k个数，直接入堆

            }else if (nums[i] > heapNode.peek()){ //如果当前元素比堆顶元素大
//                heapNode.pop();
                heapNode.poll(); //说明堆顶元素（堆中最小元素）一定不属于前k大的数，出堆
                heapNode.offer(nums[i]); //当前元素有可能属于前k大，入堆
            }
        }
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < k; i++) {
//            list.add(heapNode.pop());
            list.add(heapNode.poll());
        }
        return list;
    }


}

```



## 算法策略

`算法思想`是解决算法问题的核心，而大部分的算法解析思路都来源于以下的`七种算法策略`。

### 递归

> 递归算法是一种直接或者间接`调用自身函数`或者方法的算法。
>
> 递归算法的实质是把`问题分解成规模缩小的同类问题`的`子问题`，然后递归调用方法来表示问题的解。

#### 1. 说明

1. 递归算法实现简单，易上手
2. 递归过深，容易发生`栈溢出`

#### 2. 解析思路

主要用于解决三类问题：

1. 数据的定义是按照递归定义的（斐波那契数列 f(n) = f(n-1) + f(n-2)）
2. 问题的解法按递归实现（回溯）
3. 数据的结构形式按递归定义（树，图）

解题：

1. 明确输入输出，需要完成什么事情
2. `寻找递归结束条件`，结束递归，返回结果
3. 明确`递归关系式`，通过递归组合来解决问题

#### 3. 经典问题

##### 3.1 斐波那契数列

```java
/**
 * @user 25122
 * @date 2023/5/5
 * @time 13:42
 * 斐波那契数列   f(n) = f(n - 1) + f(n - 2)
 */
public class Fibonacci {
    

    // 0 1 1 2 3 5 8
    public int fibonacci(int n){
        //递归结束条件
        if (n == 0) return 0;
        if (n == 1) return 1;
        return fibonacci(n - 1) + fibonacci(n - 2);
    }

    public static void main(String[] args) {
        Fibonacci fibonacci = new Fibonacci();
        for (int i = 0; i < 7; i++) {
            int result = fibonacci.fibonacci(i);
            System.out.println(i + "-->" + result);
        }

    }

}

```

##### 3.2 汉诺塔问题

> 汉诺塔问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

![img](img/1.汉诺塔问题.jpg)

从左到右有A、B、C三根柱子，其中`A柱子`上面有`从小叠到大的n个圆盘`，现要求将`A柱子上的圆盘`移到`C柱子上去`，期间只有一个原则：`一次只能移到一个盘子且大盘子不能在小盘子上面`，`求移动的步骤和移动的次数`

假设n=1：

1. **A(0)->C**   1次

假设n=2:

1. A(0 1)->B(0)
2. **A(1)->C**
3. B->C   3次

假设n=3：

1. A(0 1 2)->C(0)
2. A(1 2)->B(1)
3. C(0)->B(0 1)
4. **A(2)->C(2)**
5. B(0 1)-> A(0)
6. B (1)->C (1 2)
7. A(0)->C(0 1 2) 7次

规律：移动2^n-1次

**分析一下，我们得出，符合以下规律：**

1. 把n-1个盘子 从A移动到B
2. 把第n个盘子从A移动到C
3. 把n-1个盘子从B移动C

代码：

```java
/**
 * @user 25122
 * @date 2023/5/5
 * @time 13:56
 * 汉诺塔问题
 */
public class Hanoi {

    int moveCount = 0;

    /***
     * 1. 把n-1个盘子 从A移动到B    C辅助
     * 2. 把第n个盘子从A移动到C
     * 3. 把n-1个盘子从B移动C  A辅助
     * @param n
     * @param A
     * @param B
     * @param C
     */
    public void hanoi(int n,char A,char B,char C){
        if (n == 1){
            move(n - 1,A,C);
        }else {
            hanoi(n-1,A,C,B);
            move(n-1,A,C);
            hanoi(n-1,B,A,C);
        }
    }


    private void move(int id, char src, char dist) {
        System.out.println("第" + (++moveCount) + "次，将" + id + "从" + src + "移动到" + dist);
    }

    public static void main(String[] args) {
        Hanoi hanoi = new Hanoi();
        hanoi.hanoi(3,'A','B','C');
    }

}

```

### 分而治之


> 将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，`直到更小的子问题可以简单求解`，求解子问题，则原问题的解则为`子问题解的合并`。

#### 1. 解题思路

当出现满足以下条件的问题，可以尝试只用分治策略进行求解：

1. 原始问题可以分成多个相似的子问题
2. 子问题可以很简单的求解
3. 原始问题的解是子问题解的合并
4. 各个子问题是相互独立的，不包含相同的子问题

**解题思路：**

1. 分解，将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
2. 解决，解决各个子问题

3. 合并，将各个子问题的解合并为原问题的解

#### 2. 经典问题

##### 2.1 二分查找

> 又称折半查找，是一种快速查找算法，比如 有 0-100的数，让你猜数字，每猜一次，就告诉你是猜大了还是猜小了，然后再剩下的数中 继续猜，很明显符合分治的思路



~~~java
package com.tjetc.divide;

/**
 * @user 25122
 * @date 2023/5/7
 * @time 17:24
 * 二分查找
 */
public class BinarySearch {

    /**
     * 根据传入的数组，查询指定的数字在那个位置
     *
     * @param items 数组
     * @param item  数字
     * @return
     */
    public int search(int[] items, int item) {
        //1. 分解 将数组分成左右两部分
        int low = 0;    //左边位置
        int high = items.length - 1;    //右边位置

        //2. 求解子问题  如果比中间值小，左部分查找 如果比中间值大，右部分查找 如果相等，返回
        while (low <= high) {
            int mid = (low + high) / 2;   //中间位置
            int value = items[mid]; //中间位置的值
            System.out.println("value = " + value);

            if (item < value) {
                //查询的数字 比中间值 小，左部分查找，则中间的值 变为最右边的值
                high = mid - 1;
            } else if (item > value) {
                //查询的数字 比中间值 大，右部分查找，则中间的值 变为最左边的值
                low = mid + 1;
            } else {
                return mid;
            }
            System.out.println("low = " + low);
            System.out.println("high = " + high);
            System.out.println("------------------");
        }

        return -1;
        //3. 合并
    }

    public static void main(String[] args) {
        BinarySearch binarySearch = new BinarySearch();
        int [] items =  {1,2,3,4,5,6,7,8};
        int search = binarySearch.search(items, 8);
        System.out.println("=================");
        System.out.println(search);
    }

}

~~~



##### 2.2 归并排序

> 归并排序将待排序的元素序列分成两个长度相等的子序列，为每一个子序列排序，然后再将他们合并成一个子序列。
>
> 每个子序列又重复上述过程，所以还用到了递归


~~~java
package com.tjetc.divide;

import java.sql.SQLOutput;

/**
 * @user 25122
 * @date 2023/5/8
 * @time 20:03
 * 归并排序
 */
public class MergeSort {

    /**
     * 对数组进行排序 指定初始位置 和 尾部位置
     * @param array
     * @param start
     * @param end
     */
    public void mergeSort(int [] array,int start,int end){
        //递归 有退出 条件
        if (start < end){
            //1. 分解成 两部分 左子序列 和 右子序列
            int mid = (start + end)/2;//中间位置
            //2. 解决 分布对左右子序列进行排序
            mergeSort(array,start,mid);//对左子序列排序
            mergeSort(array,mid + 1,end);//对右子序列排序
            //3. 合并
            merge(array,start,mid,end);
        }

    }


    private void merge(int[] array, int left, int mid, int right) {
        //设置一个临时数组 用于存放排序的结果
        int [] tmp = new int[array.length];
        //设置两个检测 指针 分别指向 两个左右子序列的起始 位置，分布比较左右子序列、
        //设置一个存储的指针
        int p1 = left; // 左子列 起始位置
        int p2 = mid + 1;// 右子列 起始位置
        int k = left;
        while (p1<=mid&&p2<=right){
            if (array[p1] <= array[p2]){//右别大于左边 左边 放入 tmp
                tmp[k++] = array[p1++];
            }else {//右边 小于 左边 ， 右边放入 tmp
                tmp[k++] = array[p2++];
            }
        }
        while (p1 <= mid){//左边子序列 又剩下 加到 tmp
            tmp[k++] = array[p1++];
        }
        while (p2 <= right){//右边子序列 又剩下 加到 tmp
            tmp[k++] = array[p2++];
        }
        //复制 tmp 到 array
        System.arraycopy(tmp,left,array,left,right+1-left);

    }

    public static void main(String[] args) {
        int array[] = {3,2,18,10,20,5,4,1,7,9,13};
        MergeSort mergeSort = new MergeSort();
        mergeSort.mergeSort(array,0,array.length - 1);
        for (int i : array) {
            System.out.println(i);
        }
    }


}

~~~

### 贪心算法


> 总是做出`当前的最优选择`，即期望`通过局部的最优选择`获得`整体的最优选择`。

**贪心算法仅仅只关注当前的最大利益，所以说它做出的选择仅仅是某种意义上的局部最优，但是贪心算法在很多问题上还是能够拿到最优解或较优解，所以它的存在还是有意义的。**

比如：从100张钞票中 抽取十张，如何才能获得最大的价值。`每次选剩下的最大的面值即可`。

但是有些情况下，局部最优解并不是整体最优解：

比如：求A-G的最短路径，根据贪心算法，会选择A-B，B-E,E-G，1+5+4=10，但是最优解应该是A-C,C-G 2+2=4

![贪心算法](img/2.贪心算法.jpg)



#### 3.1 解题思路

**什么时候使用贪心算法呢？**

1. 原问题复杂度过高
2. 求全局最优解的数学模型难以建立或计算量过大
3. 没有太大必要一定要求出全局最优解，“比较优”就可以

**解题思路:**

1. 明确什么是最优解
2. 把问题分成多个步骤，每一步都需要满足
   1. 可行性：每一步都满足问题的约束
   2. 局部最优：每一步都做出一个局部最优的选择
   3. 不可取消：选择一旦做出，在后面遇到任何情况都不可取消
3. 叠加所有步骤的最优解，就是全局最优解

#### 3.2 经典问题

##### 3.2.1 活动安排问题

> 设有n个活动的集合e={1，2，…，n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si< fi。如果选择了活动i，则它在半开时间区间[si，fi]内占用资源。若区间[si，fi]与区间[sj，fj]不相交，则称活动i与活动j是相容的。也就是说，当si>fj或sj>fi时，活动i与活动j相容。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。

```java
import java.util.ArrayList;
import java.util.List;

/**
 * @user 25122
 * @date 2023/5/10
 * @time 21:31
 * 活动安排问题
 */
public class Activity {

    /**
     * 以结束时间为准，只要下一个开始时间 大于上一个结束时间，最优解，最佳的活动安排
     * 如果结束时间 不符合升序，应该 先进行排序
     * @param start 活动的开始时间集合
     * @param end 活动的结束时间集合 必须是升序
     */
    public void arrange(int [] start,int[] end){
        //活动的举办时间越小 安排的活动越多
        List<Integer> result = arrangeActivity(start,end);
        for (int i = 0; i < result.size(); i++) {
            int index = result.get(i);
            System.out.println("index = " + index);
            System.out.println("开始时间：" + start[index] + ",结束时间：" + end[index]);
        }
    }

    /**
     * 安排活动
     * @param start
     * @param end
     * @return
     */
    private List<Integer> arrangeActivity(int[] start, int[] end) {
        int total = start.length;
        int endFlag = end[0];
        List<Integer> result = new ArrayList<>();
        result.add(0);
        for (int i = 0; i<total; i++){
            if (start[i] > endFlag){//下一场的开始时间必须大于上一场的结束时间
                result.add(i);
                endFlag = end[i];
            }
        }
        return result;
    }

    public static void main(String[] args) {
        Activity activity = new Activity();
        int[] start = {1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12};
        int[] end = {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
        activity.arrange(start,end);
    }
}

```

##### 3.2.2 找零钱问题

我买了一个商品，老板要找给我99，他有面值分别为25，10，5，1的硬币数，为了找给我最少的硬币数，那么他应该怎么找？

先看看该找多少个25分的，99／25＝3，那么老板只能给我3个25分的，由于还少给我24，所以还得给我2个10分的和4个1分。

```java
/**
 * @user 25122
 * @date 2023/5/11
 * @time 22:46
 */
public class Money {

    public void give(int [] m, int target ){
        //定义硬币的数值大小
        int[] nums = giveMoney(m,target);
        System.out.println("对" + target + "找零钱的方案：");
        for (int i = 0;i < nums.length ; i++){
            System.out.println("找" + nums[i] + "个" + m[i] + "的硬币");
        }
    }

    /**
     *
     * @param m 目标钱 的数值
     * @param target 需找钱数
     * @return
     */
    private int[] giveMoney(int[] m, int target) {
        int [] nums = new int[m.length];
        for (int i = 0; i< m.length; i++){
            nums[i] = target/m[i];//需找钱数/第一个数值
            target = target % m[i];//求解余下钱数
        }
        return nums;
    }

    public static void main(String[] args) {

        int [] m = {25,10,5,1};//定义硬币的数值大小
        new Money().give(m,99);
    }
}

```

### 回溯算法

> 回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。`深度优先搜索`利用的就是回溯算法思想。

#### 1. 解题思路

回溯算法很简单，它就是不断的尝试，直到拿到解。

**解题思路：**

1. 针对所给问题，确定问题的`解空间`(所有可能的解构成的集合)
   1. 首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。
2. 把问题的解空间转化为图或者树的结构表示，确定节点的扩展搜索规则
3. 使用深度优先搜索策略进行遍历，并在搜索过程中用剪枝函数避免无效搜索
4. 遍历的过程中记录和寻找所有可行解或者最优解。

> ​	回溯法按深度优先策略搜索问题的解空间树。首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用**剪枝函数**判断该节点是否可行（即能得到问题的解）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。
>
> ​    回溯法的基本行为是搜索，搜索过程使用剪枝函数来为了避免无效的搜索。剪枝函数包括两类：1. 使用约束函数，剪去不满足约束条件的路径；2.使用限界函数，剪去不能得到最优解的路径。
>
> ​    问题的关键在于如何定义问题的解空间，转化成树（即解空间树）

#### 2. 经典问题

##### 八皇后

该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：

> 在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 
> 八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解


```java
/**
 * @user 25122
 * @date 2023/5/16
 * @time 9:36
 * @describe 回溯算法
 */
public class NQueen {

    int n = 4;//棋盘大小
    int[][] boards = new int[n][n];//定义棋盘
    int result = 0;//几种解法

    /**
     * 放入一个棋子，从0开始放
     * @param k
     */
    public void put(int k){

        //解空间，符合棋子摆放的节点，每行每列放置的位置的集合，放置的位置标识为1
        //行位置 只能摆放一个，下一行开始进行搜索，下一行的0号位开始放置
        //剪枝函数：判断上面的所有行，一列 左斜杠 右斜杠 都不能为一列
        //符合条件进行记录
        if (k == n){
            result ++;
            for(int i = 0; i < n; i++){
                for (int j = 0; j < n ; j++){
                    System.out.print(boards[i][j] + " ");
                }
                System.out.println();
            }
            System.out.println();
        }else {
            for (int i = 0; i < n; i++){
                if (check(k, i)) {
                    boards[k][i] = 1;
                    put(k+1);
                    //如果不是最优解
                    boards[k][i]  = 0;
                }
            }
        }
        
    }

    private boolean check(int row, int column) {
        //是不是一列
        for (int i = 0; i < row ; i++){
            if (boards[i][column] == 1){
                return false;
            }
        }
        //是不是左斜杠
        for (int i = row - 1,j = column - 1; i >= 0&& j >= 0; i--,j--){//左上
            if (boards[i][j] == 1){
                return false;
            }
        }
        //是不是右斜杠
        for (int i = row - 1,j = column + 1; i >= 0&& j < n; i--,j++){//右上
            if (boards[i][j] == 1){
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        NQueen nQueen = new NQueen();
        nQueen.put(0);
        System.out.println("result:" + nQueen.result);
    }


}

```

### 动态规划

> 动态规划也是将复杂问题分解成小问题求解的策略，与分治算法不同的是，分治算法要求各子问题是相互独立的，而动态规划各子问题是相互关联的。

动态规划适用于子问题重叠的情况，即不同的子问题具有公共的子子问题，在这种情况下，分治策略会做出很多不必要的工作，它会反复求解那些公共子子问题，而动态规划会对每个子子问题求解一次，然后保存在表格中，如果遇到一致的问题，从表格中获取既可，所以它无需求解每一个子子问题，避免了大量的不必要操作。

#### 1. 解题思路

动态规划适用于`求解最优解问题`，比如，从面额不定的100个硬币中任意选取多个凑成10元，求怎样选取硬币才可以使最后选取的硬币数最少又刚好凑够了10元。这就是一个`典型的动态规划`问题。它可以分成`一个个子问题`（每次选取硬币），每个子问题又有`公共的子子问题`（选取硬币），`子问题之间相互关联`（已选取的硬币总金额不能超过10元），`边界条件就`是最终选取的硬币总金额为 10 元。

**解题思路：**

1. 定义子问题
2. 实现需要反复执行解决的子子问题部分
3. 识别并求解出边界条件

#### 2 经典问题

##### 2.1 爬楼梯问题

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**第一步：定义子问题**

如果用f(n)表示第 `n` 级台阶的方案数，并且由题目知：最后一步可能迈 2 个台阶，也可迈 1 个台阶，即第 `n` 级台阶的方案数等于第 `n-1` 级台阶的方案数加上第 `n-2` 级台阶的方案数

**第二步：实现需要反复执行解决的子子问题部分**

~~~java
f(n) = f(n-1) + f(n-2)
~~~

**第三步：识别并求解出边界条件**

~~~java
//0,一种方案 ,第1级也是一种方案
f(0) = 1;
f(1) = 1;
~~~

代码：

```java
package com.tjetc.dynamic;

/**
 * @user 25122
 * @date 2023/5/17
 * @time 22:17
 * @describe 爬楼梯问题
 */
public class Stairway {

    /**
     * 给出多少个台阶，给出结果【递归】
     * @param n
     * @return
     */
    public int climb(int n){
        //边界条件
        if (n == 0) return 1;//0阶楼梯 1种方法
        if (n == 1) return 1;//1阶楼梯 1种
        int result = 2;//2阶 2种  --   3阶 3种   -- 4阶 5种
        for (int i=2;i<=n;i++){
            result = climb(i-1) + climb(i-2);//i阶 结果 = i-1阶结果 + i-2 阶结果
        }
        return result;
    }

    /**
     * 给出多少个台阶，给出结果【非递归】
     * @param n
     * @return
     */
    public int climb1(int n){
        //边界条件
        int result = 1;
        //前n-2阶台阶结果数
        int n2 = 1;
        //前n-1阶台阶结果数
        int n1 = 1;
        for (int i=2;i<=n;i++){
            result = n1 + n2;
            n2 = n1;
            n1 = result;
        }
        return result;//当前台阶结果数

    }

    public static void main(String[] args) {
        int climb = new Stairway().climb1(4);
        System.out.println(climb);
    }



}

```

### 枚举策略

> 枚举算法的思想是：将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，丢弃不合适的

#### 1. 解题思路

- 确定枚举对象、枚举范围和判定条件。
- 逐一列举可能的解，验证每个解是否是问题的解。

枚举算法步骤：

1. 确定解题的可能范围，不能遗漏任何一个真正解，同时避免重复。

2. 判定是否是真正解的方法。

3. 为了提高解决问题的效率，使可能解的范围将至最小，

#### 2. 经典问题

##### 2.1 百钱买鸡

> 公鸡每只5元，母鸡每只3元，三只小鸡1元，用100元买100只鸡，问公鸡、母鸡、小鸡各多少只？

算法分析：

利用枚举法解决该问题，

以三种鸡的个数为枚举对象,分别设为mj,gj和xj，

用三种鸡的总数 （mj+gj+xj=100）和买鸡钱的总数（1/3*xj+mj*3+gj*5=100）作为判定条件，穷举各种鸡的个数。

```java
package com.tjetc.enums;

/**
 * @user 25122
 * @date 2023/5/21
 * @time 19:58
 * @describe 百钱买鸡
 */
public class BuyChicken {

    public static void main(String[] args) {

        //声明母鸡、公鸡、小鸡数量
        int mj = 0;
        int gj = 0;
        int xj = 0;
        //声明买鸡方式个数
        int count = 0;
        //母鸡 3元 （最多买33只）、公鸡 5元（最多买20只）、 小鸡（最多买100只）三只一元 一只 1/3元
        for (gj = 0; gj <= 20; gj++) {
            for (mj = 0; mj <= 33; mj++){
                xj = 100 - mj - gj;
                //判断条件 小鸡数目必须是三的倍数 ，所有鸡加起来 100 元
                if (xj%3 == 0 && (xj/3 * 1 + mj * 3 + gj * 5 == 100)){
                    count++;
                    System.out.println("100元可以买公鸡：" + gj + "只，母鸡：" + mj + "只，小鸡：" + xj + "只");
                }
            }
        }
        System.out.println("共" + count + "种买法");
    }

}

```

### 分支限界法


> 类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。
> 回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，
> 或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的`最优解`。

所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，
抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。

选择下一个结点的方式不同，则会有几种不同的分支搜索方式：

- FIFO搜索（先进先出 队列）
- LIFO搜索 （后进先出 栈）
- 优先队列式搜索

#### 1. 解题思路

1. 定义解空间 确定解空间包括解的组织形式和显约束(范围限定)
2. 确定解空间的组织结构 通常用解空间树形象的表达(只是辅助理解并不是真的树)
3. 搜索解空间 按照**广度优先搜索**，根据限制条件，搜索问题的解

#### 2. 经典问题

##### 2.1 背包问题

> 设有n个物体和一个背包,物体i的重量为wi价值为pi ,背包的载荷为M, 若将物体i（1<= i <=n）装入背包,则有价值为pi . 
> 目标是找到一个方案, 使得能放入背包的物体总价值最高. 设N=3, W=(16,15,15),  P=(45,25,25), C=30（背包容量）

**队列式分支限界法**

可以通过画分支限界法状态空间树的搜索图来理解具体思想和流程

每一层按顺序对应一个物品放入背包（1）还是不放入背包（0）

![](img/3.背包问题.jpg)

由图可看出 符合要求的有（1 0 0,0 1 1,0 0 1）最优解为 0 1 1

步骤：

**①** 用一个队列存储活结点表，初始为空

**②** A为当前扩展结点，其儿子结点B和C均为可行结点，将其按从左到右顺序加入活结点队列，并舍弃A。

**③** 按FIFO原则，下一扩展结点为B，其儿子结点D不可行，舍弃；E可行，加入。舍弃B

**④** C为当前扩展结点，儿子结点F、G均为可行结点，加入活结点表，舍弃C

**⑤** 扩展结点E的儿子结点J不可行而舍弃；K为可行的叶结点，是问题的一个可行解，价值为45

**⑥** 当前活结点队列的队首为F, 儿子结点L、M为可行叶结点，价值为50、25

**⑦** G为最后一个扩展结点，儿子结点N、O均为可行叶结点，其价值为25和0

**⑧** 活结点队列为空，算法结束，其最优值为50

注：活结点就是不可再进行扩展的节点，也就是两个儿子还没有全部生成的节点

代码：

```java
package com.tjetc.limit;

/**
 * @user 25122
 * @date 2023/5/28
 * @time 10:14
 * @describe 分支限界法-定义变量
 */
public class Node {

    //物品重量
    private int weight;
    //物品价值
    private int value;
    //物品所在节点层级
    private int level;
    //父节点
    private Node parent;

    public boolean isLeft() {
        return isLeft;
    }

    public void setLeft(boolean left) {
        isLeft = left;
    }

    //是否选择左子节点
    private boolean isLeft;

    public Node() {
    }

    public Node(int weight, int value, int level, Node parent, boolean isLeft) {
        this.weight = weight;
        this.value = value;
        this.level = level;
        this.parent = parent;
        this.isLeft = isLeft;
    }

    public int getWeight() {
        return weight;
    }

    public void setWeight(int weight) {
        this.weight = weight;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public int getLevel() {
        return level;
    }

    public void setLevel(int level) {
        this.level = level;
    }

    public Node getParent() {
        return parent;
    }

    public void setParent(Node parent) {
        this.parent = parent;
    }
}

```

```java
package com.tjetc.limit;

import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;

/**
 * @user 25122
 * @date 2023/5/28
 * @time 10:20
 * @describe 背包
 */
public class Knapsack {
    //最优节点
    private static Node bestNode;
    //活节点队列 长度3
    private static Queue<Node> queue = new ArrayBlockingQueue<>(3);
    //物品的重量
    private static int w[] = {16, 15, 15};
    //物品的价值
    private static int v[] = {45, 25, 25};
    //背包的容量
    private static int c = 30;
    //已选择物品的重量
    private static int cw = 0;
    //已选择物品的价值
    private static int cv = 0;
    //装入背包的物品的最优价值
    private static int bestV = 0;
    //物品的个数
    private static int n = w.length;

    public static void main(String[] args) {
        int i = 0;//当前的层级
        Node parent = null;
        while (i < n) {
            //当前重量
            int tw = w[i] + cw;
            //判断当前重量 和 背包容量大小，<则放入
            if (tw <= c) {
                //判断当前物品价值 和 最优价值
                if (cv + v[i] > bestV) {
                    bestV = cv + v[i];
                }
                addLiveNode(cw + w[i], cv + v[i], i + 1, parent, true);
            }
            //不放入
            int bound = maxBound(i);
            if (cv + bound > bestV) {
                addLiveNode(cw, cv, i + 1, parent, false);

            }
            //从队列中取出删掉
            Node node = queue.poll();
            i = node.getLevel();
            cw = node.getWeight();
            cv = node.getValue();
            parent = node;
        }
        System.out.println(bestV);
        for (int j = n - 1; j >= 0; j--){
            System.out.println(bestNode.isLeft() ? 1 : 0);
            bestNode = bestNode.getParent();
        }

    }

    /**
     * 最大边界值
     *
     * @param i
     * @return
     */
    private static int maxBound(int i) {
        int bound = 0;
        for (int level = i + 1; level < n; level++) {
            bound += v[level];
        }
        return bound;
    }

    /**
     * @param w      重量
     * @param v      价值
     * @param level  层级
     * @param parent 父节点
     * @param isLeft 是否是活节点
     */
    private static void addLiveNode(int w, int v, int level, Node parent, boolean isLeft) {

        Node node = new Node(w, v, level, parent, isLeft);
        queue.add(node);
        if (level == n && v == bestV) {
            bestNode = node;
        }

    }

}

```

## 常见算法

### 查找算法

#### 1. 基本查找/顺序查找

```java
package com.lxy25122.search;

/**
 * @user 25122
 * @date 2023/8/27
 * @time 20:52
 * @description 基本查找/顺序查找
 * 核心：从第0个索引开始挨个往后查找
 */
public class A01_BasicSearchDemo1 {

    /**
     * 需求：定义一个方法利用基本查找，查询某个元素是否存在
     * 数据如下：{132,12,43,64,3,75,3,1}
     */
    public static void main(String[] args) {
        int [] arr = {132,12,43,64,3,75,3,1};
        int number = 132;
        boolean result = basicSearch(arr, number);
        System.out.println(result);
    } 

    /**
     *
     * @param arr 数组
     * @param number 要查找的元素
     * @return 元素是否存在
     */
    public static boolean basicSearch(int[] arr, int number){
        //利用基本查找来查找number在arr数组中是否存在
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == number) return true;
        }
        return false;
    }

}
```

**扩展**

```java
package com.lxy25122.search;

import java.util.ArrayList;
import java.util.List;

/**
 * @user 25122
 * @date 2023/8/27
 * @time 20:52
 * @description 基本查找/顺序查找
 * 核心：从第0个索引开始挨个往后查找
 */
public class A01_BasicSearchDemo2 {

    /**
     * Exe1
     * 需求：定义一个方法利用基本查找，查询某个元素在数组中的索引
     * 要求：不需要考虑数组中元素是否重复
     * <p>
     * Exe2：
     * 需求：定义一个方法利用基本查找，查询某个元素在数组中的索引
     * 要求：需要考虑数组中元素有重复的可能性
     * {132,12,43,64,3,75,3,1,12}
     * 需要查找12，想要返回的是所有索引 1 8
     * 如果要返回多个数据的话，可以把这些数据放到数组或者集合中
     */
    public static void main(String[] args) {
        int[] arr = {132, 12, 43, 64, 3, 75, 3, 1, 12};
        int number = 2;
        int index = exe1(arr, number);
        System.out.println(index);
        System.out.println("---------------------");
        List<Integer> integers = exe2(arr, 12);
        System.out.println(integers);
    }


    public static int exe1(int[] arr, int number) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == number) return i;
        }
        return -1;
    }

    public static List<Integer> exe2(int[] arr, int number) {
        ArrayList<Integer> arrayList = new ArrayList<Integer>();
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == number) arrayList.add(i);
        }
        return arrayList;
    }


}
```

#### 2. 二分查找/折半查找

```java
package com.lxy25122.search;

/**
 * @user 25122
 * @date 2023/8/28
 * @time 20:20
 * @description 二分查找/折半查找
 * 核心：每次排除一半的查找范围
 * 1、数据必须是有序的（前提）
 * 2、查找过程：
 *  min和max表示当前要查找的范围
 *  mid在min和max中间的
 *  如果要查找的元素在mid的左边，在缩小范围的时候，min不变，max等于mid减1
 *  如果要查找的元素在mid的右边，在缩小范围的时候，max不变，min等于mid加1
 * <br></br>
 * 二分查找：mid每次都是指向范围的中间位置
 * 插值查找：mid尽可能的靠近要查找的数据，但是要求数据尽可能分别均匀
 * 斐波那契查找：根据黄金分割点来计算mid指向的位置
 */
public class A02_BinarySearchDemo1 {

    /**
     * 需求：定义一个方法利用二分查找，查询某个元素在数组中的索引
     * 数据如下：{2,7,9,13,25,26,47,58,70,99,121}
     * min      mid     max
     */
    public static void main(String[] args) {
        int[] arr = {2,7,9,13,25,26,47,58,70,99,121};
        int index = binarySearch(arr, 13);
        System.out.println(index);
    }

    /**
     * 二分查找/折半查找
     * @param arr 数组
     * @param number 要查找的元素
     * @return 索引位置
     */
    public static int binarySearch(int[] arr, int number){
        //1、定义两个变量，记录要查找的范围
        int min = 0;
        int max =arr.length - 1;
        //2、利用循环不断的去找要查找的数据
        while (true){
            if (min > max){
                return -1;
            }
            //3、找到min和max的中间位置 mid
            int mid = (min + max)/2;
            //4、拿着mid指向的元素跟要查找的元素进行比较
            if (number < arr[mid]){
                //4.1、number在mid的左边
                // min不变，max=mid-1
                max = mid - 1;
            }else if (number > arr[mid]){
                //4.2、number在mid的右边
                //min = mid + 1，max不变
                min = mid + 1;
            }else {
                //4.3、number跟mid指向的元素一样
                //mid = number
                return mid;
            }
        }
    }

}

```

#### 3. 插值查找

```java
public class InterpolationSearch {  
    public static int interpolationSearch(int[] arr, int x) {  
        int low = 0;  
        int high = arr.length - 1;  
  
        while (low <= high && x >= arr[low] && x <= arr[high]) {  
            if (low == high) {  
                if (arr[low] == x) return low;  
                return -1;  
            }  
  
            int pos = low + ((x - arr[low]) * (high - low)) / (arr[high] - arr[low]);  
  
            if (arr[pos] == x) return pos;  
  
            if (arr[pos] < x) low = pos + 1;  
            else high = pos - 1;  
        }  
  
        return -1;  
    }  
  
    public static void main(String[] args) {  
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15};  
        int x = 7;  
        int index = interpolationSearch(arr, x);  
        if (index != -1) System.out.println("Element found at index: " + index);  
        else System.out.println("Element not found in the array");  
    }  
}
```

在这个程序中，我们首先设定一个低位(low)和高位(high)。然后，我们使用目标值(x)与数组的低端和高端的差值，来计算出一个位置(pos)。这个位置是根据插值公式计算出来的，这个公式就是 `pos = low + ((x - arr[low]) * (high - low)) / (arr[high] - arr[low])`。然后我们检查这个位置的值是否等于目标值。如果等于，我们就返回这个位置。如果这个位置的值小于目标值，我们就把低位移动到这个位置的右边一位。否则，我们就把高端移动到这个位置的左边一位。然后我们重复这个过程，直到低位大于高端，或者我们找到目标值。

#### 4. 分块查找

```java
package com.lxy25122.search;

/**
 * @user 25122
 * @date 2023/8/28
 * @time 21:35
 * @description 分块查找
 * 核心思想：块内无序，块间有序
 * 实现步骤：
 *  1、创建数组BlockArr存放每一块对象的信息
 *  2、先查找blockArr确定要查找的数据属于那一块
 *  3、再单独遍历这一块数据即可
 */
public class A03_BlockSearchDemo1 {

    public static void main(String[] args) {

        int[] arr = {
                16, 5, 9, 12, 21, 18,
                32, 23, 37, 26, 45, 34,
                50, 48, 61, 52, 73, 66
        };
        //1. 要把数据进行分块
        //  要分为几块：arr.length=18 开根号 4.24块
        //  18/4 = 4.5块

        //创建三个块的对象
        Block block1 = new Block(21,0,5);
        Block block2 = new Block(45,6,11);
        Block block3 = new Block(66,12,17);

        //定义数组用来管理三个块的对象（索引表）
        Block[] blockArr = {block1,block2,block3};

        //定义一个变量用来记录要查找的元素
        int number = 37;

        //调用方法，传递、索引表，数组，要查找的元素
        int index = getIndex(blockArr,arr,number);
        System.out.println(index);

    }

    /**
     * 利用分块查找的原理，查询number的索引 ✔
     * @param blockArr
     * @param arr
     * @param number
     * @return
     */
    private static int getIndex(Block[] blockArr, int[] arr, int number) {
        //1.确定number在那一块当中
        int indexBlock = findIndexBlock(blockArr, number);
        if (indexBlock == -1){
            //表示number不在数组当中
            return -1;
        }
        //2. 获取这一块的起始索引和结束索引
        //获取当前块的对象
        Block block = blockArr[indexBlock];
        int startIndex = block.getStartIndex();
        int endIndex = block.getEndIndex();
        //3. 遍历原始数组
        for (int i = startIndex; i <= endIndex; i++){
            if (arr[i] == number){
                return i;
            }
        }
        return -1;
    }

    /**
     * 确定number在索引表的位置
     * @return
     */
    public static int findIndexBlock(Block[] blockArr, int number){
//        Block block1 = new Block(21,0,5);     ---0
//        Block block2 = new Block(45,6,11);    ---1
//        Block block3 = new Block(66,12,17);   ---2
        //从0索引开始遍历blockArr，如果number小于max，那么就表示number是在这一块当中的
        for (int i = 0; i < blockArr.length; i++) {
            if (number <= blockArr[i].getMax()){
                return i;
            }
        }
        return -1;
    }


}

class Block{

    private int max;//最大值
    private int startIndex;//起始索引
    private int endIndex;//结束索引

    public Block() {
    }

    public Block(int max, int startIndex, int endIndex) {
        this.max = max;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
    }

    public int getMax() {
        return max;
    }

    public void setMax(int max) {
        this.max = max;
    }

    public int getStartIndex() {
        return startIndex;
    }

    public void setStartIndex(int startIndex) {
        this.startIndex = startIndex;
    }

    public int getEndIndex() {
        return endIndex;
    }

    public void setEndIndex(int endIndex) {
        this.endIndex = endIndex;
    }
}

```

**扩展**

```java
package com.lxy25122.search;

/**
 * @user 25122
 * @date 2023/8/28
 * @time 21:35
 * @description 【扩展的分块查找，块内无序，块外无序】
 * 核心思想：块内无序，块间有序
 * 实现步骤：
 *  1、创建数组BlockArr存放每一块对象的信息
 *  2、先查找blockArr确定要查找的数据属于那一块
 *  3、再单独遍历这一块数据即可
 */
public class A03_BlockSearchDemo2 {

    public static void main(String[] args) {

        int[] arr = {
                27, 22, 30, 40, 36,
                13, 19, 16, 20,
                7, 10,
                43, 50, 48
        };
        //1. 要把数据进行分块
        //  要分为几块：arr.length=18 开根号 4.24块
        //  18/4 = 4.5块

        //创建四个块的对象
        Block2 block1 = new Block2(40,22,0,4);
        Block2 block2 = new Block2(20,13,5,8);
        Block2 block3 = new Block2(10,7,9,10);
        Block2 block4 = new Block2(50,43,11,13);

        //定义数组用来管理三个块的对象（索引表）
        Block2[] blockArr = {block1,block2,block3,block4};

        //定义一个变量用来记录要查找的元素
        int number = 7;

        //调用方法，传递、索引表，数组，要查找的元素
        int index = getIndex(blockArr,arr,number);
        System.out.println(index);

    }

    /**
     * 利用分块查找的原理，查询number的索引 ✔
     * @param blockArr
     * @param arr
     * @param number
     * @return
     */
    private static int getIndex(Block2[] blockArr, int[] arr, int number) {
        //1.确定number在那一块当中
        int indexBlock = findIndexBlock(blockArr, number);
        if (indexBlock == -1){
            //表示number不在数组当中
            return -1;
        }
        //2. 获取这一块的起始索引和结束索引
        //获取当前块的对象
        Block2 block = blockArr[indexBlock];
        int startIndex = block.getStartIndex();
        int endIndex = block.getEndIndex();
        //3. 遍历原始数组
        for (int i = startIndex; i <= endIndex; i++){
            if (arr[i] == number){
                return i;
            }
        }
        return -1;
    }

    /**
     * 确定number在索引表的位置
     * @return
     */
    public static int findIndexBlock(Block2[] blockArr, int number){
//        Block2 block1 = new Block2(40,22,0,4);        --0
//        Block2 block2 = new Block2(20,13,5,8);        --1
//        Block2 block3 = new Block2(10,7,9,10);        --2
//        Block2 block4 = new Block2(50,43,11,13);      --3
        //从0索引开始遍历blockArr，如果number小于max，那么就表示number是在这一块当中的
        for (int i = 0; i < blockArr.length; i++) {
            if (number <= blockArr[i].getMax() && blockArr[i].getMin() <= number){
                return i;
            }
        }
        return -1;
    }


}

class Block2{

    private int max;//最大值
    private int min;//最小值
    private int startIndex;//起始索引
    private int endIndex;//结束索引

    public Block2() {
    }

    public Block2(int max, int min, int startIndex, int endIndex) {
        this.max = max;
        this.min = min;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
    }

    public int getMax() {
        return max;
    }

    public void setMax(int max) {
        this.max = max;
    }

    public int getMin() {
        return min;
    }

    public void setMin(int min) {
        this.min = min;
    }

    public int getStartIndex() {
        return startIndex;
    }

    public void setStartIndex(int startIndex) {
        this.startIndex = startIndex;
    }

    public int getEndIndex() {
        return endIndex;
    }

    public void setEndIndex(int endIndex) {
        this.endIndex = endIndex;
    }

}
```

### 排序算法

#### 1.冒泡排序✔

相邻的数据两两比较，小的放前面，大的放后面。

```java
package com.lxy25122.mysort;

/**
 * @user 25122
 * @date 2023/9/3
 * @time 10:43
 * @description 冒泡排序
 * 核心思想
 * 1、相邻的元素两两比较，大的放右边，小的放左边。
 * 2、第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推。
 * 3、如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以。
 *
 */
public class A01_BubbleDemo1 {

    public static void main(String[] args) {

        //1.定义数组
        int[] arr = {2, 4, 5, 3, 1};
        //2.利用冒泡排序将数组中的数据变成 1 2 3 4 5
        //第一轮：结束之后，最大值在数组的最右边。。。。5
//        for (int i = 0; i < arr.length - 1; i++) {
//            //i 依次表示数组中的每一个索引： 0 1 2 3 4
//            if (arr[i] > arr[i + 1]){
//                int temp = arr[i];
//                arr[i] = arr[i + 1];
//                arr[i + 1] = temp;
//            }
//        }
//        printArr(arr);
//        //第二轮：
//        for (int i = 0; i < arr.length - 1 - 1; i++) {
//            //i 依次表示数组中的每一个索引： 0 1 2 3 4
//            if (arr[i] > arr[i + 1]){
//                int temp = arr[i];
//                arr[i] = arr[i + 1];
//                arr[i + 1] = temp;
//            }
//        }
//        printArr(arr);
        //最终代码：
        //外循环：表示我要执行多少轮，如果有n个数据，那么执行n-1轮
        for (int i = 0; i < arr.length - 1; i++) { // 0 1 2 3
            //内循环：每一轮中我如何比较数据并找到当前的最大值
            //-1：为了防止索引越界
            //-i：提高效率，每一轮执行的次数应该比上一轮少一次
            for (int j = 0; j < arr.length - 1 - i; j++){
                //i 依次表示数组中的每一个索引： 0 1 2 3 4
                if (arr[j] > arr[j + 1]){
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
            printArr(arr);
        }

    }

    public static void printArr(int[] arr){
        //3.遍历数组
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "、");
        }
        System.out.println();
    }

}
```



#### 2.选择排序✔

从0索引开始，拿着每一个索引上的元素跟后面的元素依次比较，小的放前面，大的放后面，依次类推

```java
package com.lxy25122.mysort;

/**
 * @user 25122
 * @date 2023/9/4
 * @time 21:27
 * @description 选择排序
 * 1、从 0 索引开始，跟后面的元素一一比较。
 * 2、小的放前面，大的放后面。
 * 3、第一次循环结束后，最小的数据已经确定。
 * 4、第二次循环从 1 索引开始以此类推。
 */
public class A02_SelectionDemo1 {

    public static void main(String[] args) {
        //1.定义数组
        int[] arr = {2, 4, 5, 3, 1};
        //2.利用选择排序让数组变成 1 2 3 4 5
        //第一轮：从 0 索引开始，跟后面元素一一比较
//        for (int i = 0 + 1; i < arr.length; i++) {
//            //拿着 0 索引跟后面的数据进行比较
//            if (arr[0] > arr[i]){
//                int temp = arr[0];
//                arr[0] = arr[i];
//                arr[i] = temp;
//            }
//        }
        //最终代码：
        //外循环：i 表示这一轮中，拿着哪个索引上的数据跟后面的数据进行比较并交换
        for (int i = 0; i < arr.length - 1; i++) {
            //内循环：拿着 i 跟 i 后面的数据进行比较交换
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] > arr[j]){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
        }

        printArr(arr);
    }


    public static void printArr(int[] arr){
        //3.遍历数组
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "、");
        }
        System.out.println();
    }

}

```





#### 3.插入排序

将数组分为有序和无序两组，遍历无序数据，将元素插入有序序列中即可

```java
package com.lxy25122.mysort;

/**
 * @user 25122
 * @date 2023/9/6
 * @time 10:39
 * @description 插入排序
 * 将 0 索引的元素到 N 索引的元素看做是有序的，把 N+1 索引的元素到最后一个当做是无序的，
 * 遍历无序的数据，将遍历的元素插入有序序列中适当位置，如遇到相同数据，插在后面，
 * N 的范围：0到最大索引
 */
public class A03_InsertDemo1 {

    public static void main(String[] args) {
        int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};
        //1.找到无序的那一组数据是从哪个索引开始的。index-2
        int startIndex = -1;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > arr[i + 1]){
                System.out.println(i);//表示有序的那一组数据到 1 索引就结束了
                startIndex = i + 1;
                break;
            }
        }
        System.out.println("------------------");
        //2.遍历从startIndex 开始到最后一个元素，依次得到无序的那一组数据中的每一个元素
//        int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};

        for (int i = startIndex; i < arr.length; i++) {
//            System.out.println(arr[i]);
            //开始向有序的数据中插入
            //记录当前要插入数据的索引
            int j = i;
            while (j > 0 && arr[j] < arr[j - 1]){
                //交换位置
                int temp = arr[j];
                arr[j] = arr[j - 1];
                arr[j - 1] = temp;
                j--;
            }

            //修改这个索引

        }

        printArr(arr);

    }

    public static void printArr(int[] arr){
        //3.遍历数组
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "、");
        }
        System.out.println();
    }

}

```





#### 4.快速排序

**递归算法**

指的是方法中调用本身的现象

注意：递归一定要有出口，否则就会出现内存溢出

作用：

- 把一个复杂的问题层层转化为一个**与原问题相似的规模较小**的问题
- 递归策略只需**少量的程序**就可描述出解题过程所需要的多次重复计算

核心：

- 找出口：什么时候不再调用方法
- 找规则：如何把大问题变成规模较小的问题

eg：递归求和，求1-100之间的和

```java
package com.lxy25122.mysort;

/**
 * @user 25122
 * @date 2023/9/11
 * @time 20:46
 * @description 递归求1-100之间的和
 * 100 + 99 + 98 + .. + 2 + 1
 * 1~100 = 100 + (1~99)
 * 1~99 = 99 + (1~98)
 * 1~98 = 98 + (1~97)
 * ...
 * 1~3 = 3 + (1 ~ 2)
 * 1~2 = 2 + (1 ~ 1)
 * 1~1 = 1(递归出口)
 */
public class A04_RecursionDemo2 {

    public static void main(String[] args) {
        int sum = getSum(100);
        System.out.println(sum);//5050
    }

    public static int getSum(int number){
        //如果是1
        if (number == 1){
            return 1;
        }
        //如果不是1
        return number + getSum(number - 1);
    }

}

```

eg：递归求5的阶乘

```java
package com.lxy25122.mysort;

/**
 * @user 25122
 * @date 2023/9/11
 * @time 20:46
 * @description 递归求5的阶乘
 * 核心：
 *
 * - 找出口：什么时候不再调用方法
 * - 找规则：如何把大问题变成规模较小的问题
 * 5! = 5 * 4!
 * 4! = 4 * 3!
 * 3! = 3 * 2!
 * 2! = 2 * 1!
 * 1! = 1(递归出口)
 */
public class A04_RecursionDemo3 {

    public static void main(String[] args) {

        int sum2 = deliveryX(5);
        System.out.println(sum2);//120
    }

    public static int deliveryX(int number){
        if (number == 1){
            return 1;
        }
        return number * deliveryX(number - 1);
    }


}

```

**快速排序**

第一轮：把0索引的数字作为基准数，确定基准数在数组中正确的位置。比基准数小的全部在左边，比基准数大的全部在右边

后续递归操作，完成排序

```java
package com.lxy25122.mysort;

import javafx.scene.input.DataFormat;

import java.util.Date;

/**
 * @user 25122
 * @date 2023/9/12
 * @time 16:05
 * @description 快速排序
 * 第一轮：
 * 把 0 索引的数字作为基准数，确定基准数在数组中正确的位置。
 * 比基准数小的全部在左边，比基准数大的全部在右边，【先从结束索引开始比较】
 * 后面以此类推， end索引和start索引都移动位置后 进行互换
 *
 */
public class A05_QuickSortDemo {

    public static void main(String[] args) {
        /**
         *    {6, 1【start】, 2, 7, 9, 3, 4, 5, 10, 8【end】} end
         *    基准数：0->6，起始索引：1->1，结束索引：arr.length-1->8
         *    6,1【start】,2,7,9,3,4,5【end】,10,8 start
         *    6,1,2,5【start】,9,3,4,7【end】,10,8 end
         *    6,1,2,5,4【start】,3,9【end】,7,10,8 start
         *    6,1,2,5,4【start】,3【end】,9,7,10,8 end
         *    6,1,2,5,4,3【start】【end】,9,7,10,8 start
         *    3,1,2,5,4,6【start|end】，9,7,10,8 一轮结束
         */
        int arr[] = {6, 1, 2, 7, 9, 3, 4, 5, 10, 8};
        long start = System.currentTimeMillis();
        quickSort(arr,0,arr.length - 1);
        long end = System.currentTimeMillis();
        System.out.println(end - start);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + ",");
        }
    }

    /**
     * 快速排序
     * @param arr 要排序的数组
     * @param startIndex 数组的起始索引
     * @param endIndex  数组的结束索引
     */
    public static void quickSort(int arr[], int startIndex, int endIndex){
        //定义两个变量记录要查找的范围
        int start = startIndex;
        int end = endIndex;

        if (start > end){
            //递归出口
            return;
        }

        //记录基准数
        int baseNumber = arr[startIndex];
        //利用循环找到要交换的数字
        while (start != end){
            //1、利用 end 从后往前开始找，比基准数小的数字
            while (true){
                //结束索引位置 <= 起始索引位置 || 结束索引位置的值 < 基准数
                if (end <= start || arr[end] < baseNumber){
                    break;
                }
                end--;//不满足条件，结束索引向左移一位
            }
            //2、利用 start 从前往后找，比基准数大的数字
            while (true){
                //结束索引位置 <= 起始索引位置 || 起始索引位置的值 > 基准数
                if (end <= start || arr[start] > baseNumber){
                    break;
                }
                start++;//不满足条件，起始索引向右移一位
            }
            //交换 end 和 start 指向的元素
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
        }
        //当start和end指向了同一个元素的时候，那么上面的循环就会结束
        //表示已经找到了基准数在数组中应存入的位置
        //3、基准数归位 就是拿着这个范围中的第一个数字，跟start指向的元素进行交换
        int temp = arr[startIndex];
        arr[startIndex] = arr[start];
        arr[start] = temp;
        //一轮结束结果：3,1,2,5,4,6,9,7,10,8,
        //确定 6 左边的范围，重复刚刚调用【递归】
        quickSort(arr,startIndex,start - 1);
        //确定 6 右边的范围【递归】
        quickSort(arr, start + 1, endIndex);

    }

}

```



### 综合练习

#### 1.按照要求进行排序

定义数组并存储一些女朋友对象，利用Arrays中的sort方法进行排序

要求1：属性有姓名、年龄、身高。

要求2：按照年龄的大小进行排序，年龄一样，按照身高排序，身高一样按照姓名的字母进行排序。

(姓名中不要有中文或特殊字符，会涉及到后面的知识)

**GirlFriend.java**

```java
package com.lxy25122.testExe;

import jdk.nashorn.internal.objects.annotations.Constructor;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @user 25122
 * @date 2023/9/14
 * @time 15:54
 * @description 练习一
 *
 * 要求1：属性有姓名、年龄、身高。
 *
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class GirlFriend {

    private String name;

    private Integer age;

    private double height;


}
```

**Test1.java**

```java
package com.lxy25122.testExe;

import java.util.Arrays;
import java.util.Comparator;

/**
 * @user 25122
 * @date 2023/9/14
 * @time 15:51
 * @description 练习一
 * 定义数组并存储一些女朋友对象，利用Arrays中的sort方法进行排序
 *
 * 要求1：属性有姓名、年龄、身高。
 *
 * 要求2：按照年龄的大小进行排序，年龄一样，按照身高排序，身高一样按照姓名的字母进行排序。
 *
 * (姓名中不要有中文或特殊字符，会涉及到后面的知识)
 *
 */
public class Test1 {

    public static void main(String[] args) {

        //1.创建三个女朋友对象
        GirlFriend gf1 = new GirlFriend("xiaotu",18,1.67);
        GirlFriend gf2 = new GirlFriend("xiaobai",18,1.67);
        GirlFriend gf3 = new GirlFriend("xiaomei",21,1.65);
        //2.定义数组存储女朋友信息
        GirlFriend[] arr = {gf1,gf2,gf3};
        //3.利用Arrays 中的 sort 方法进行排序
//        //匿名内部类方式
//        Arrays.sort(arr, new Comparator<GirlFriend>() {
//            @Override
//            public int compare(GirlFriend o1, GirlFriend o2) {
//                //要求2：按照年龄的大小进行排序，年龄一样，按照身高排序，身高一样按照姓名的字母进行排序。
//                double temp = o1.getAge() - o2.getAge();//比较年龄
//                temp = temp == 0 ? o1.getHeight() - o2.getHeight() : temp;//比较身高
//                temp = temp == 0 ? o1.getName().compareTo(o2.getName()) : temp;//比较姓名字母
//                if (temp > 0){
//                    return 1;
//                }else if (temp < 0){
//                    return -1;
//                }else {
//                    return 0;
//                }
//            }
//        });
        //Lambda方式
        Arrays.sort(arr, (o1, o2) -> {
                //要求2：按照年龄的大小进行排序，年龄一样，按照身高排序，身高一样按照姓名的字母进行排序。
                double temp = o1.getAge() - o2.getAge();//比较年龄
                temp = temp == 0 ? o1.getHeight() - o2.getHeight() : temp;//比较身高
                temp = temp == 0 ? o1.getName().compareTo(o2.getName()) : temp;//比较姓名字母
                if (temp > 0){
                    return 1;
                }else if (temp < 0){
                    return -1;
                }else {
                    return 0;
                }
            }
        );
        //4.展示数组中的内容
        System.out.println(Arrays.toString(arr));


    }


}

```

#### 2.不死神兔

有一个很有名的数学逻辑题叫做不死神兔问题，有一对兔子，从出生后第三个月起每个月都生一对兔子,小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问第十二个月的兔子对数为多少？

![image-20230915133528986](https://gitee.com/tjlxy/img/raw/master/image-20230915133528986.png)

```java
package com.lxy25122.testExe;

/**
 * @user 25122
 * @date 2023/9/15
 * @time 13:36
 * @description 不死神兔
 * 有一个很有名的数学逻辑题叫做不死神兔问题，有一对兔子，从出生后第三个月起每个月都生一对兔子,
 * 小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问第十二个月的兔子对数为多少？
 * 特点：从第三个数据开始，是前两个数据的和（斐波那契数列）
 */
public class Test2 {

    public static void main(String[] args) {
        //求解一：
        //1.创建一个长度为12的数组
        int[] arr = new int[12];
        //2.手动给 0 索引和 1 索引的数据进行赋值
        arr[0] = 1;
        arr[1] = 1;
        //3.利用循环给剩余的数据进行赋值
        for (int i = 2; i < arr.length; i++) {
            arr[i] = arr[i - 1] + arr[i - 2];

        }
        //4.获取最大索引上的数据即可
        System.out.println(arr[11]);
        System.out.println("-------------------------");

        //求解二：
        /**
         * 递归的方式去完成
         * 1.递归的出口
         * 2.找到递归的规律
         * Fn(12) = Fn(11) + Fn(10)
         * Fn(11) = Fn(10) + Fn(9)
         * Fn(10) = Fn(9) + Fn(8)
         * ...
         * Fn(3) = F(2) + F(1)
         * Fn(2) = 1
         * Fn(1) = 1
         */
        System.out.println(getSum(12));
    }

    public static Integer getSum(int month){
        if (month == 1 || month == 2){
            return 1;
        }else {
            return getSum(month - 1) + getSum(month - 2);
        }
    }

}

```



#### 3.猴子吃桃子

有一堆桃子，猴子第一天吃了其中的一半，并多吃了一个！

以后每天猴子都吃当前剩下来的一半，然后再多吃一个，

第18天的时候（还没吃），发现只利下一个桃子了，请问，最初总共多少个桃子？

```java
package com.lxy25122.testExe;

/**
 * @user 25122
 * @date 2023/9/16
 * @time 21:13
 * @description 猴子吃桃子
 * 有一堆桃子，猴子第一天吃了其中的一半，并多吃了一个！
 * 以后每天猴子都吃当前剩下来的一半，然后再多吃一个，
 * 第18天的时候（还没吃），发现只利下一个桃子了，请问，最初总共多少个桃子？
 *
 * 分析：
 * day 10：  1
 * day 9：   (day10 + 1) * 2 = 4
 * day 8：   (day9 + 1) * 2 = 10
 * day 7：   (day8 + 1) * 2 = 22
 * ...
 * day 1:   (day2 + 1) * 2 = ?
 *
 *
 * 1.出口
 *  day==10 剩下1
 * 2.规律
 *  每一天桃子数量都是后一天数量加1，乘以2
 *
 *  反向递归
 */
public class Test3 {

    public static void main(String[] args) {
//        long start = System.currentTimeMillis();
        int count = getCount(1);
//        long end = System.currentTimeMillis();
        System.out.println(count);
//        System.out.println(start - end);
    }

    public static int getCount(int day){
        if (day <= 0 || day >11){
            System.out.println("当前时间错误");
            return -1;
        }
        //递归出口
        if (day == 10){
            return 1;
        }else {
            return (getCount(day + 1) + 1) * 2;
        }

    }

}

```



#### 4.爬楼梯

可爱的小明特别喜欢爬楼梯，他有的时候一次爬一个台阶，有的时候一次爬两个台阶。

如果这个楼梯有20个台阶，小明一共有多少种爬法呢？

运算结果：

1层台阶、1种爬法

2层台阶、2种爬法

7层台阶、21种爬法

```java
package com.lxy25122.testExe;

/**
 * @user 25122
 * @date 2023/9/17
 * @time 11:26
 * @description 爬楼梯
 * 可爱的小明特别喜欢爬楼梯，他有的时候一次爬一个台阶，有的时候一次爬两个台阶。
 *
 * 如果这个楼梯有20个台阶，小明一共有多少种爬法呢？
 * 运算结果：
 *
 * 1 层台阶、1种爬法
 *
 * 2 层台阶、2种爬法
 *
 * 7 层台阶、21种爬法
 *
 * --------------------------
 * 分析：
 * 1    1
 * 2    11,2
 * 3    111,12,21
 * 4    1111,112,121,211,22
 * 5    11111,1112,1121,1211,122,2111,212,221,
 */
public class Test4 {

    public static void main(String[] args) {
        System.out.println(getCount(20));
    }

    public static int getCount(int n){
        if (n == 1){
            return 1;
        }
        if (n == 2){
            return 2;
        }
        return getCount(n - 1) + getCount(n - 2);
    }

}

```

**扩展**

可爱的小明特别喜欢爬楼梯，他有的时候一次爬一个台阶，有的时候一次爬两个台阶，有的时候一次爬三个台阶。

如果这个楼梯有20个台阶，小明一共有多少种爬法呢？

```java
package com.lxy25122.testExe;

/**
 * @user 25122
 * @date 2023/9/17
 * @time 11:26
 * @description 爬楼梯
 * 可爱的小明特别喜欢爬楼梯，他有的时候一次爬一个台阶，有的时候一次爬两个台阶，有的时候一次爬三个台阶。
 *
 * 如果这个楼梯有20个台阶，小明一共有多少种爬法呢？
 * 运算结果：
 *
 * 1 层台阶、1种爬法
 *
 * 2 层台阶、2种爬法
 *
 *
 *
 * --------------------------
 * 分析：
 * 1    1                                                           1
 * 2    11,2                                                        2
 * 3    111,12,21,3                                                 4
 * 4    1111,112,121,13,211,22,31                                   7
 * 5    11111,1112,1121,113,1211,122,131,
 *      2111,212,221,23,
 *      311,32                                                      13
 * 6    111111,11112,11121,1113,11211,1122,1131,12111,1212,1221,123,1311,132
 *      21111,2112,2121,213,2211,222,231
 *      3111,312,321,33                                             24
 *
 */
public class Test5 {

    public static void main(String[] args) {
        System.out.println(getCount(1));
        System.out.println(getCount(2));
        System.out.println(getCount(3));
        System.out.println(getCount(4));
        System.out.println(getCount(5));
        System.out.println(getCount(6));
    }

    public static int getCount(int n){
        if (n == 1){
            return 1;
        }else if (n == 2){
            return 2;
        }else if (n == 3){
            return 4;
        }
        return getCount(n - 1) + getCount(n - 2) + getCount(n - 3);
    }

}

```



