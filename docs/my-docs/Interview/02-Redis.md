# Redis

## Redis基础

### 1.Redis是什么？简述它的优缺点✔

Redis是一个key-value类型的内存数据库，<font color=red>**整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存**</font>

优点：

1、基于内存，读写性能极高，（110000/s、80000/s）

2、丰富的数据结构：字符串、哈希、集合、有序集合、列表

3、支持**持久化**：AOF、RDB

4、**支持事务**

5、支持主从复制

6、发布订阅

7、分布式锁

缺点：

1、不适合海量数据的高性能读写，压垮内存

2、主从架构，**降低了系统的可用性**（**主机宕机造成数据不一致问题**）

### 2.Redis为什么这么快✔

1、基于内存存储，没有磁盘上的开销

2、单线程实现，单线程处理请求，避免的多个线程之间线程切换和锁资源争用的开销

**3、非阻塞IO，使得处理大量并发请求而不会出现阻塞情况**

4、提供了多种数据结构，并对每种数据结构进行了高度优化

5、内部使用的底层模式不同，实现了多种优化机制

### 3.Redis相比Memcached有哪些优势

1、Redis有丰富的数据类型；Memcached几乎都是字符串类型

2、**Redis支持数据持久化，可以将内存中的数据保存到磁盘中，重启的时候再次加载**；Mecached不支持数据持久化存储

3、**Redis支持主从同步机制，以及集群部署能力，能够提供高可用服务**；Mecached没有原生的集群模式

4、<font color=red>**性能对比；网络IO模型；数据操作**</font>

### 4.为什么要用redis做缓存

1、<font color=red>**高并发**</font>

- 将部分数据缓存到Redis上，避免请求数据库，导致数据库压力过大

2、<font color=red>**高性能**</font>

- 首次请求数据库从硬盘中读取，速度较慢
- 使用Redis后直接操作内存，速度较快

### 5.为什么要用redis而不用map/guava做缓存

1、速度

2、数量

3、主从，集群

4、数据类型

5、**持久化**

6、**稳定性**

。。。

### 6.Redis的常用场景有哪些✔✏️

1、缓存：传统、击穿、雪崩、双写一致、数据过期、淘汰策略

2、**分布式锁**

3、**计数器**

4、**会话存储（token）**

5、**消息队列**

6、**延迟队列**

### 7.Redis的数据类型有哪些

常用

- 1、字符串：`String`
- 2、哈希：`Hash`
- 3、列表：`List`
- 4、集合：`set`
- 5、有序集合：`sort set`

其他

- 1、**地理位置**：`Geo`
- 2、**位图**：`Bitmap`
- 3、`Hyperloglog`
- 4、流：`stream`

### Redis大key怎么处理✔

Redis大key指的是在Redis中存储的**某个key对应的value数据量很大**的情况下可能会出现的问题和解决办法

<font color=red>**引发的问题**</font>

1、内存占用

- 大key占用大量的内存资源，导致Redis实例的内存压力增加

2、**网络传输延迟**

- 大key的读写操作，可能会增加网络传输的延迟，影响性能

3、持久化备份

- 大key的持久化备份需要更多的磁盘空间和时间

**解决办法**

1、把大key分割成多个小key来存储，可以减少单个key的大小，降低内存压力

2、搭建Redis cluster集群，把key分配到不同的hash slot槽所在的分片上，降低单个Redis节点的存储压力

3、**如果已经存在大key，可以做数据的拆分和迁移，按照业务需求和规则将大key拆分成多个小key，并分布到不同Redis实例上，然后在迁移完了之后清理调用不需要使用的大key**

4、可以使用压缩算法进行压缩去减少存储空间的占用，也就是说在存储数据之前对数据进行压缩，在读取的时候进行解压缩，以节省存储空间和减少网络传输的数据量

5、**从业务层面进行分析，了解大key产生的原因，并根据需求和访问模式进行相应的优化**

## 持久化

### 8.Redis持久化机制✔

1、RDB【Redis database backup file】-Redis数据备份文件

- **简单来说就是把内存中所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据（宕机会丢失最后一次快照后的数据）**

2、AOF【append only file】-追加文件

- **将Redis中所有写指令记录下来，以日志的方式追加在后面**
- **就是说当Redis写命令的时候，都会存储这个文件当中，当Redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来、恢复数据**

### 9.如何选择合适的持久化方式  

- 数据不敏感
  - 可以关闭持久化
- 数据比较重要
  - 使用`rdb`
- 做内存数据库，使用Redis的持久化
  - `rdb+aof`

### 10.Redis持久化数据和缓存怎么做扩容

- 如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。
- 如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。

## 过期键的删除策略、淘汰策略

### 11.Redis过期键的删除策略✔✏️

- 定时删除

  - 过期时间到来时，对其执行删除
  - 对CPU不友好，对内存友好

- **惰性删除**

  在设置该key过期时间后，我们不去管它，当需要该key 时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。

  - 当需要该key时，检查是否过期
  - 对内存不友好，对CPU友好

- **定期删除**

  就是说每隔一段时间，我们就对一些key进行检查，删除里面过期的key

  1、slow模式是定时任务

  2、fast模式执行频率不固定

  - 每隔一段时间，对key进行检查
  - 双刃剑
    - 可以通过限制删除操作执行的时长和频率来减少删除操作对Cpu的影响。另外定期删除，也能有效释放过期键占用的内存
    - 难以确定删除操作执行的时长和频率

惰性删除	+	定期删除两种策略进行配合使用。

### 12.Redis key的过期时间和永久有效分布怎么设置✏️

- expire
- pexpire

### 13.Redis内存淘汰策略✔（缓存过多，内存是有限的，内存被占满了怎么办）

当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存淘汰策略。



Redis支持8种不同策略来选择要删除的key：

1. noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。
2. volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰
3. allkeys-random：对全体key ，随机进行淘汰。
4. volatile-random：对设置了TTL的key ，随机进行淘汰。
5. allkeys-lru： 对全体key，基于LRU算法进行淘汰
6. volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰
7. allkeys-lfu： 对全体key，基于LFU算法进行淘汰
8. volatile-lfu： 对设置了TTL的key，基于LFU算法进行淘汰

> **LRU**（**L**east **R**ecently **U**sed）最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。
>
> **LFU**（**L**east **F**requently **U**sed）最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。
>
> **数据淘汰策略-使用建议**
>
> 1.优先使用 allkeys-lru 策略。充分利用 LRU 算法的优势，把最近最常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。
>
> 2.如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用 allkeys-random，随机选择淘汰。
>
> 3.如果业务中有置顶的需求，可以使用 volatile-lru 策略，同时置顶数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据。
>
> 4.如果业务中有短时高频访问的数据，可以使用 allkeys-lfu 或 volatile-lfu 策略。、
>
> **关于数据淘汰策略其他的面试问题**
>
> 1.数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中的数据都是热点数据 ? 
>
> 使用allkeys-lru(挑选最近最少使用的数据淘汰)淘汰策略，留下来的都是经常访问的热点数据
>
> 2.Redis的内存用完了会发生什么？
>
> 主要看数据淘汰策略是什么？如果是默认的配置（ noeviction ），会直接报错

- ` allkeys-lru：`移除最近最少使用的key

## 缓存异常

### 14.如何保证缓存与数据库双写时的数据一致性✔❤✏️

当修改了数据库中的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致

读操作：

- 缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间

写操作：

- 延迟双删【有脏数据风险】

  - 先删除缓存，后更新数据库

  - 先更新数据库，后删除缓存

    延迟双删，如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定，在延时的过程中可能会出现脏数据，并不能保证强一致性，所以没有采用它。

- **Redisson读写锁【强一致、性能低】**

  在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写，读读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是读方法和写方法上需要使用同一把锁才行。 排他锁底层使用也是setnx，保证了同时只能有一个线程操锁住的方法

  - 强一致性的，采用Redisson提供的读写锁

    ①共享锁：读锁readLock，加锁之后，其他线程可以共享读操作

    ②排他锁：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作

- **异步的方案同步的数据**【最终一致】

  - 允许延时一致的业务，采用异步通知

    ①使用MQ中间件，更新数据之后，通知缓存删除

    - 数据库写入：当需要对数据库进行写操作时，首先更新数据库中的数据。
    - 发送消息：在数据库数据写入成功后，发送一条消息到消息队列。消息中包含了被更新的数据的标识符或其他必要信息。
    - 消费消息：消息队列中有一个消费者，负责监听并消费这些消息。一旦消费者接收到消息，它将根据消息中的信息执行相应的操作。
    - 更新 Redis 缓存：消费者从消息中获取到被更新的数据标识符后，它将根据标识符从数据库中读取最新的数据，并将这个数据更新到 Redis 缓存中，确保缓存与数据库保持一致。

    通过以上步骤，可以将 Redis 缓存与数据库的数据保持同步。当数据库数据发生变化时，消息队列中的消息将触发消费者执行相应的操作，以更新 Redis 缓存中对应的数据。

    ②利用canal中间件，不需要修改业务代码，部署一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据， 更新缓存即可。

### 17.什么是缓存击穿✔❤

- 高并发访问，某个热点的key失效，无数的请求访问，引发数据库的压力并发。

  就是说给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮

- 解决方案

  1. 互斥锁

     - 当缓存失效时，不立即去load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db的操作并回设缓存，否则重试get缓存的方法
     - 优点：强一致
     - 缺点：性能差

  2. 设置永不过期

     1. 物理不过期，针对热点key不设置过期时间

     2. 逻辑过期

        - ①：在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前 key设置过期时间

          ②：当查询的时候，从redis取出数据后判断时间是否过期

          ③：如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据， 这个数据不是最新

        - 优点：高可用，性能优

        - 缺点：不能保证数据绝对一致

### 18.什么是缓存穿透✔

- 缓存中不存在，数据库中也不存在

  就是说查询一个不存在的数据，MySQL查询不到数据也不会之间去写入缓存，就会导致每次请求查数据库

- 解决方案

  1. 缓存空数据

     - 查询返回的数据为空，仍把这个空结果进行缓存，将无效的key存放进redis中
     - 优点：实现简单，
     - 缺点：销毁内存，可能发送不一致的问题

  2. 使用布隆过滤器

     - 查询布隆过滤器，不存在，直接返回，存在（缓存预热时，预热布隆过滤器）查Redis，命中直接放回结果，查不到，查数据库，查到结果，存到Redis并返回结果。

       布隆过滤器主要是用于检索一个元素是否在一个集合中。

     - 优点：内存占用较小，没有多余key

     - 缺点：实现复制，存在误判

### 19.什么是缓存雪崩✔

- 某一时刻出现大规模的key失效或Redis宕机，导致大量请求到达数据库，带来巨大压力

  就是说设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB 瞬时压力过重雪崩。与缓存击穿的区别： 雪崩是很多key，击穿是某一个key缓存。

- 解决方案

  - 给不同的key的TTL添加随机值

    （主要）

    - 缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件

  - 利用Redis集群提高服务的可用性

  - 给缓存业务添加降级限流策略

  - 给业务添加多级缓存

注意：**降级限流可做为系统的保底策略，适用于穿透、击穿、雪崩**

### 20.什么是缓存预热

- 指系统上线后，提前将相关的缓存数据加载到缓存系统

### 21.什么是缓存降级✏️

- 在缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。

## 线程模型

### 22.Redis为何选择单线程✏️

Redis基于内存操作，执行速度非常快，真正的瓶颈在于网络IO

选择单线程的原因：

1、避免过多的上下文切换开销

- 如果是单线程则可以规避进程内频繁的线程切换开销，因为程序始终运行在进程中单个线程内，没有多线程切换的场景。

2、简单可维护

- 如果 Redis使用多线程模式，那么所有的底层数据结构都必须实现成线程安全的，这无疑又使得 Redis的实现变得更加复杂。

3、<font color=red>**避免同步机制的开销**</font>

- 如果 Redis选择多线程模型，又因为 Redis是一个数据库，那么势必涉及到底层数据同步的问题，则必然会引入某些同步机制，比如锁，而我们知道 Redis不仅仅提供了简单的 key-value 数据结构，还有 list、set 和 hash 等等其他丰富的数据结构，而不同的数据结构对同步访问的加锁粒度又不尽相同，可能会导致在操作数据过程中带来很多加锁解锁的开销，增加程序复杂度的同时还会降低性能。

### 23.Redis真的是单线程

Redis6.0引入多线程I/O，只是用来处理**网络数据的读写和协议的解析**，而执行命令仍然是单线程

### 24.Redis6.0为何引入多线程✏️

Redis单线程模式会导致系统消耗很多CPU，在网络IO上从而降低吞吐量

### 25.Redis6.0采用多线程后，性能提升效果如何

### 26.介绍下Redis的线程模型

### 27.Redis 6.0 多线程的实现机制

### 28.Redis6.0开启多线程后，是否会存在线程并发安全问题

（不考虑线程安全问题）

Redis多线程部分只是用来处理网络数据的读写和协议的解析，执行命令仍然是单线程顺序执行

### 29.Redis6.0与Memcached多线程模型的对比✏️

- 相同点：都采用了Master线程-worker线程的模型
- 不同点
  - Memcached执行逻辑也是在worker线程里，模型更加简单，符合线程隔离
  - Redis执行逻辑交给Master线程，增加了模型复杂度，解决了线程并发安全等问题

## 事务

### 30.Redis事务的概念✏️ 

1. Redis事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。 鉴于这个原因，所以**说Redis的事务严格意义上来说是不具备原子性的**。
2. Redis事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
3. 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。**然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行**。

### 31.Redis事务的三个阶段

1、开启事务（`multi`）

2、**大量指令入队**（`Queueing`）

3、执行事务块内命令（`exec`截止此处，一个事务已经结束）

- `discard`取消事务
- `watch`监视一个或多个key，如果事务执行前key被改动，事务将打断，`unwatch`取消监视。
- 【如果执行过程中，服务端收到其他命令请求，会将请求放入到队列中排队】

### 32.Redis事务相关命令✏️

- `Watch`监控一个或多个键，持续到EXEC命令
- `Multi`
- `Exec`
- `Discard`
- `UnWatch`取消对所有key的监控

### 33.Redis事务支持隔离性吗✏️

- Redis是单线程程序，Redis事务总数带有隔离性的

### 34.Redis为什么不支持事务回滚

- **Redis命令只会因为错误的语法而失败**，或是命令用在了错误类型的键上面，失败的命令是由编程错误造成的，而这些错误应该在开发过程中被发现，而不应该出现在生产环境中

### 35.Redis事务其他实现

## 主从、哨兵、集群

### 36.Redis常见使用方式有哪些✔✏️

- 单副本
  - 数据量少适用
- 多副本（主从）
  - 可用性不高，基本不用（master节点挂掉之后需要手动指定新的master）
- Sentinel（哨兵）
  - 数据量不是很多，集群规模不是很大，需要自动容错的时候适用
- Cluster（Redis分片集群）
  - 海量数据+高并发+高可用的场景
- 自研

### 37.介绍下Redis的单副本

- 单个Redis节点部署架构
- 优点
  - 部署简答
  - 性价比高
  - 高性能
- 缺点
  - 不能保证数据的可靠性，没有备用节点
  - 适合操作命令简单、排序、计算较少的场景

### 38.介绍下Redis多副本（主从）✔

- 主从部署架构，提高数据持久化和备份策略
- 优点
  - 可靠性高
  - 读写分离
- 缺点
  - 故障恢复赋值
  - 主库写能力和存储能力受到单机的限制

### 介绍一下主从同步✔

单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据之后，需要把数据同步到从节点中

### 主从同步数据的流程✔✏️

主从同步分为了两个阶段，一个是全量同步，一个是增量同步

全量同步是指从节点第一次与主节点建立连接的时候使用全量同步，流程是这样的：

第一：从节点请求主节点同步数据，其中从节点会携带自己的replication id 和offset偏移量。

第二：主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点就会把自己的replication id和offset发送给从节点，让从节点与主节点的信息保持一致。

第三：在同时主节点会执行bgsave，生成rdb文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发送过来的rdb文件，这样就保持了一致

当然，如果在rdb生成执行期间，依然有请求到了主节点，而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步

增量同步指的是，当从节点服务重启之后，数据就不一致了，所以这个时候，从节点会请求主节点同步数据，主节点还是判断不是第一次请求，不是第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步

###  39.介绍下Redis Sentinel（哨兵）✔

- 优点
  - 部署简单
  - 高可用
  - 可扩展
  - 可以实现Sentinel监控
- 缺点
  - 部署相比主从模式要复杂
  - 资料浪费
  - 不能解决读写分离问题，实现起来相对复杂

### 怎么保证Redis的高并发高可用✔



### 使用redis是单点还是集群，哪种集群✔



### redis集群脑裂，该怎么解决呢✔



### 40.介绍下Redis Cluster （分片集群）✔



### redis的分片集群有什么作用✔



### Redis分片集群中数据是怎么存储和读取的✔



### 41.介绍下Redis自研



### 42.Redis高可用方案具体怎么实施✔



### 43.了解主从复制原理吗✔❤



### 44.由于主从延迟导致读取到过期数据怎么处理



### 45.主从复制的过程中，如果因为网络原因停止复制了会怎么样



### 46.Redis主从架构数据会丢失吗，为什么



### 47.如何解决主从架构数据丢失的问题



### 48.Redis哨兵是怎么工作的

### 49.故障转移时会从剩下的slave选举一个新的master，被选举为master的标准是什么



### 50.同步配置的时候其他哨兵根据什么更新自己的配置呢

### 51. 为什么Redis哨兵集群只有2个节点无法正常工作



### 52.Redis cluster中是如何实现数据分布式的？这种方式有什么优点

### 53.Redis cluster节点间通信是什么机制

## 分布式问题

### 54.什么是分布式锁？为什么用分布式锁



### 55.常见的分布式锁有哪些解决方案



### 56.Redis实现分布式锁✔



### 57.了解RedLock吗

### 58.RedLock的原理

## 其他

### 59.Redis如何做内存优化



### 60.如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计

### 怎么使用Redis实现一个延时队列✔





 
